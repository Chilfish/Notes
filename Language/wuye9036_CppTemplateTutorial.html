<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <link rel="icon" href="https://notes.organicfish.top/logo.png"><title>C++ Template 进阶指南 | Fish's Notes</title><meta name="description" content="基于 Vuepress 的笔记 blog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-d91b3d01.css" as="style"><link rel="stylesheet" href="/assets/style-d91b3d01.css">
    <link rel="modulepreload" href="/assets/app-42b6f949.js"><link rel="modulepreload" href="/assets/framework-cf51392c.js"><link rel="modulepreload" href="/assets/wuye9036_CppTemplateTutorial.html-a88199ac.js"><link rel="modulepreload" href="/assets/wuye9036_CppTemplateTutorial.html-c0c0c48d.js"><link rel="prefetch" href="/assets/index.html-b7b52957.js" as="script"><link rel="prefetch" href="/assets/DP.html-f2dccdee.js" as="script"><link rel="prefetch" href="/assets/Math.html-83c5ba6c.js" as="script"><link rel="prefetch" href="/assets/miao.html-43cc7590.js" as="script"><link rel="prefetch" href="/assets/index.html-1dda0055.js" as="script"><link rel="prefetch" href="/assets/Search.html-579a5c5e.js" as="script"><link rel="prefetch" href="/assets/Sort.html-73dbb5a5.js" as="script"><link rel="prefetch" href="/assets/STL.html-7587794b.js" as="script"><link rel="prefetch" href="/assets/not_JustCode.html-c7064858.js" as="script"><link rel="prefetch" href="/assets/index.html-bf8aca51.js" as="script"><link rel="prefetch" href="/assets/TempCoder.html-a518b40a.js" as="script"><link rel="prefetch" href="/assets/ToDo.html-9f0cd621.js" as="script"><link rel="prefetch" href="/assets/index.html-f4c60b5e.js" as="script"><link rel="prefetch" href="/assets/CSS.html-7703c264.js" as="script"><link rel="prefetch" href="/assets/HTML.html-7f16853d.js" as="script"><link rel="prefetch" href="/assets/index.html-70d037ba.js" as="script"><link rel="prefetch" href="/assets/index.html-0f3a7746.js" as="script"><link rel="prefetch" href="/assets/Cpp.html-856b5d21.js" as="script"><link rel="prefetch" href="/assets/CSharp.html-c7ac352a.js" as="script"><link rel="prefetch" href="/assets/LaTeX.html-562c7ab9.js" as="script"><link rel="prefetch" href="/assets/MySQL.html-29b70f0a.js" as="script"><link rel="prefetch" href="/assets/PHP.html-382b54da.js" as="script"><link rel="prefetch" href="/assets/Python.html-ad0ffdc6.js" as="script"><link rel="prefetch" href="/assets/index.html-ef44d27d.js" as="script"><link rel="prefetch" href="/assets/Regex.html-72fb3a8a.js" as="script"><link rel="prefetch" href="/assets/LinearList.html-05b6a55b.js" as="script"><link rel="prefetch" href="/assets/LinkedList.html-6cffe5af.js" as="script"><link rel="prefetch" href="/assets/index.html-ed787a65.js" as="script"><link rel="prefetch" href="/assets/Tree.html-9c23585b.js" as="script"><link rel="prefetch" href="/assets/index.html-4dd698a0.js" as="script"><link rel="prefetch" href="/assets/index.html-2c5e07f6.js" as="script"><link rel="prefetch" href="/assets/index.html-e303de0b.js" as="script"><link rel="prefetch" href="/assets/Linux.html-0546a92c.js" as="script"><link rel="prefetch" href="/assets/index.html-9960c9de.js" as="script"><link rel="prefetch" href="/assets/Browser.html-b38172a4.js" as="script"><link rel="prefetch" href="/assets/Git_GitHub.html-a15eba4c.js" as="script"><link rel="prefetch" href="/assets/Ajax.html-1419a5d3.js" as="script"><link rel="prefetch" href="/assets/Async.html-91da3fa5.js" as="script"><link rel="prefetch" href="/assets/base.html-a7ef1669.js" as="script"><link rel="prefetch" href="/assets/BOM.html-6ebc621d.js" as="script"><link rel="prefetch" href="/assets/DOM.html-6f795489.js" as="script"><link rel="prefetch" href="/assets/ES6.js.html-cfc41b60.js" as="script"><link rel="prefetch" href="/assets/Events.html-f7f6ec69.js" as="script"><link rel="prefetch" href="/assets/JavaScript开发者应懂的33个概念_ignore.html-efef7099.js" as="script"><link rel="prefetch" href="/assets/JQuery.html-42a9f5fc.js" as="script"><link rel="prefetch" href="/assets/Object.html-dc8aab93.js" as="script"><link rel="prefetch" href="/assets/index.html-bba29be9.js" as="script"><link rel="prefetch" href="/assets/Express.html-2381e75b.js" as="script"><link rel="prefetch" href="/assets/index.html-d94319ce.js" as="script"><link rel="prefetch" href="/assets/index.html-06501835.js" as="script"><link rel="prefetch" href="/assets/index.html-a7119a62.js" as="script"><link rel="prefetch" href="/assets/ShoppingCart.demo.html-42f50fc4.js" as="script"><link rel="prefetch" href="/assets/index.html-bddb07ca.js" as="script"><link rel="prefetch" href="/assets/index.html-6d6f55c9.js" as="script"><link rel="prefetch" href="/assets/index.html-a758d79d.js" as="script"><link rel="prefetch" href="/assets/2022.html-16852026.js" as="script"><link rel="prefetch" href="/assets/JavaSE.html-90662a18.js" as="script"><link rel="prefetch" href="/assets/index.html-e08dd4f5.js" as="script"><link rel="prefetch" href="/assets/DNS.html-cccecf03.js" as="script"><link rel="prefetch" href="/assets/HTTP.html-2beba795.js" as="script"><link rel="prefetch" href="/assets/index.html-e4b5122d.js" as="script"><link rel="prefetch" href="/assets/IP.html-675bf54c.js" as="script"><link rel="prefetch" href="/assets/index.html-7b0730d3.js" as="script"><link rel="prefetch" href="/assets/Router.html-6679dc65.js" as="script"><link rel="prefetch" href="/assets/index.html-ea8e2c7a.js" as="script"><link rel="prefetch" href="/assets/P2P_backup.html-6a28caa2.js" as="script"><link rel="prefetch" href="/assets/index.html-a90d5d18.js" as="script"><link rel="prefetch" href="/assets/index.html-b45f0ee3.js" as="script"><link rel="prefetch" href="/assets/TCP.html-a9a9ec07.js" as="script"><link rel="prefetch" href="/assets/404.html-81a48005.js" as="script"><link rel="prefetch" href="/assets/index.html-162cdb18.js" as="script"><link rel="prefetch" href="/assets/index.html-7b054cb8.js" as="script"><link rel="prefetch" href="/assets/index.html-958ceb36.js" as="script"><link rel="prefetch" href="/assets/index.html-874667dd.js" as="script"><link rel="prefetch" href="/assets/DP.html-43035523.js" as="script"><link rel="prefetch" href="/assets/Math.html-ddb02e3d.js" as="script"><link rel="prefetch" href="/assets/miao.html-609cdc47.js" as="script"><link rel="prefetch" href="/assets/index.html-4ec8cd2f.js" as="script"><link rel="prefetch" href="/assets/Search.html-bdc21d8f.js" as="script"><link rel="prefetch" href="/assets/Sort.html-a3b5a2f0.js" as="script"><link rel="prefetch" href="/assets/STL.html-02f28c41.js" as="script"><link rel="prefetch" href="/assets/not_JustCode.html-67bc1312.js" as="script"><link rel="prefetch" href="/assets/index.html-d408e468.js" as="script"><link rel="prefetch" href="/assets/TempCoder.html-055d2684.js" as="script"><link rel="prefetch" href="/assets/ToDo.html-c841783b.js" as="script"><link rel="prefetch" href="/assets/index.html-7bf8d249.js" as="script"><link rel="prefetch" href="/assets/CSS.html-56e0285b.js" as="script"><link rel="prefetch" href="/assets/HTML.html-b713401f.js" as="script"><link rel="prefetch" href="/assets/index.html-a5a685ef.js" as="script"><link rel="prefetch" href="/assets/index.html-787d7b07.js" as="script"><link rel="prefetch" href="/assets/Cpp.html-981091c2.js" as="script"><link rel="prefetch" href="/assets/CSharp.html-ad37f9b3.js" as="script"><link rel="prefetch" href="/assets/LaTeX.html-c911a5f3.js" as="script"><link rel="prefetch" href="/assets/MySQL.html-8acb9d37.js" as="script"><link rel="prefetch" href="/assets/PHP.html-14476f48.js" as="script"><link rel="prefetch" href="/assets/Python.html-5fa5247d.js" as="script"><link rel="prefetch" href="/assets/index.html-0fd31860.js" as="script"><link rel="prefetch" href="/assets/Regex.html-5ff0a4db.js" as="script"><link rel="prefetch" href="/assets/LinearList.html-a3f87d21.js" as="script"><link rel="prefetch" href="/assets/LinkedList.html-f0350eea.js" as="script"><link rel="prefetch" href="/assets/index.html-167c8e9c.js" as="script"><link rel="prefetch" href="/assets/Tree.html-10b097eb.js" as="script"><link rel="prefetch" href="/assets/index.html-44fc0a2e.js" as="script"><link rel="prefetch" href="/assets/index.html-3d09a90d.js" as="script"><link rel="prefetch" href="/assets/index.html-6644b613.js" as="script"><link rel="prefetch" href="/assets/Linux.html-2779f5b4.js" as="script"><link rel="prefetch" href="/assets/index.html-61e07759.js" as="script"><link rel="prefetch" href="/assets/Browser.html-47dad973.js" as="script"><link rel="prefetch" href="/assets/Git_GitHub.html-cf876a03.js" as="script"><link rel="prefetch" href="/assets/Ajax.html-6d4287c2.js" as="script"><link rel="prefetch" href="/assets/Async.html-17b57664.js" as="script"><link rel="prefetch" href="/assets/base.html-749a3364.js" as="script"><link rel="prefetch" href="/assets/BOM.html-5a747dea.js" as="script"><link rel="prefetch" href="/assets/DOM.html-160fbee9.js" as="script"><link rel="prefetch" href="/assets/ES6.js.html-2e1bf231.js" as="script"><link rel="prefetch" href="/assets/Events.html-89294ae1.js" as="script"><link rel="prefetch" href="/assets/JavaScript开发者应懂的33个概念_ignore.html-d0cee0f7.js" as="script"><link rel="prefetch" href="/assets/JQuery.html-de26add1.js" as="script"><link rel="prefetch" href="/assets/Object.html-4c19a6c9.js" as="script"><link rel="prefetch" href="/assets/index.html-3923f787.js" as="script"><link rel="prefetch" href="/assets/Express.html-404b1ed8.js" as="script"><link rel="prefetch" href="/assets/index.html-c3aea451.js" as="script"><link rel="prefetch" href="/assets/index.html-11383658.js" as="script"><link rel="prefetch" href="/assets/index.html-e460bfe2.js" as="script"><link rel="prefetch" href="/assets/ShoppingCart.demo.html-10aec6f5.js" as="script"><link rel="prefetch" href="/assets/index.html-1f933084.js" as="script"><link rel="prefetch" href="/assets/index.html-c281520e.js" as="script"><link rel="prefetch" href="/assets/index.html-6efb8292.js" as="script"><link rel="prefetch" href="/assets/2022.html-f00b3328.js" as="script"><link rel="prefetch" href="/assets/JavaSE.html-b32232c5.js" as="script"><link rel="prefetch" href="/assets/index.html-3f857479.js" as="script"><link rel="prefetch" href="/assets/DNS.html-09212cc7.js" as="script"><link rel="prefetch" href="/assets/HTTP.html-6c8b396f.js" as="script"><link rel="prefetch" href="/assets/index.html-2426a5c4.js" as="script"><link rel="prefetch" href="/assets/IP.html-f8d54fa4.js" as="script"><link rel="prefetch" href="/assets/index.html-238101e6.js" as="script"><link rel="prefetch" href="/assets/Router.html-92eed136.js" as="script"><link rel="prefetch" href="/assets/index.html-6a8dfced.js" as="script"><link rel="prefetch" href="/assets/P2P_backup.html-fe992340.js" as="script"><link rel="prefetch" href="/assets/index.html-4ca3897e.js" as="script"><link rel="prefetch" href="/assets/index.html-df1433a3.js" as="script"><link rel="prefetch" href="/assets/TCP.html-70291884.js" as="script"><link rel="prefetch" href="/assets/404.html-692c02a9.js" as="script"><link rel="prefetch" href="/assets/index.html-d66f6fe6.js" as="script"><link rel="prefetch" href="/assets/index.html-cae5d18b.js" as="script"><link rel="prefetch" href="/assets/index.html-7c833022.js" as="script"><link rel="prefetch" href="/assets/Catalog-ca9a5320.js" as="script"><link rel="prefetch" href="/assets/mermaid.esm.min-bc08675d.js" as="script"><link rel="prefetch" href="/assets/mermaid-mindmap.esm.min-7adb0397.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-a9093b7c.js" as="script"><link rel="prefetch" href="/assets/Sakana-77bd2e86.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container no-sidebar has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.png" alt="Fish&#39;s Notes"><!----><span class="site-name hide-in-pad">Fish&#39;s Notes</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/Language/" class="nav-link active" aria-label="编程语言"><span class="font-icon icon iconfont icon-code" style=""></span>编程语言<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="算法"><span class="title"><span class="font-icon icon iconfont icon-ability" style=""></span>算法</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/Algorithm/" class="nav-link" aria-label="首页"><span class="font-icon icon iconfont icon-home" style=""></span>首页<!----></a></li><li class="dropdown-item"><a href="/Algorithm/DS/" class="nav-link" aria-label="数据结构"><span class="font-icon icon iconfont icon-diagram" style=""></span>数据结构<!----></a></li><li class="dropdown-item"><a href="/Algorithm/Sort.html" class="nav-link" aria-label="排序算法"><span class="font-icon icon iconfont icon-sort" style=""></span>排序算法<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="前端"><span class="title"><span class="font-icon icon iconfont icon-html" style=""></span>前端</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/FrontEnd/" class="nav-link" aria-label="目录"><span class="font-icon icon iconfont icon-filter" style=""></span>目录<!----></a></li><li class="dropdown-item"><a href="/FrontEnd/JavaScript/" class="nav-link" aria-label="JavaScript"><span class="font-icon icon iconfont icon-javascript" style=""></span>JavaScript<!----></a></li><li class="dropdown-item"><a href="/FrontEnd/Node.js/" class="nav-link" aria-label="Node.js"><span class="font-icon icon iconfont icon-nodeJS" style=""></span>Node.js<!----></a></li><li class="dropdown-item"><a href="/FrontEnd/TypeScript/" class="nav-link" aria-label="TypeScript"><span class="font-icon icon iconfont icon-typescript" style=""></span>TypeScript<!----></a></li><li class="dropdown-item"><a href="/FrontEnd/Vue/" class="nav-link" aria-label="Vue.js"><span class="font-icon icon iconfont icon-vue" style=""></span>Vue.js<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="其他一些"><span class="title"><span class="font-icon icon iconfont icon-article" style=""></span>其他一些</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/balabala/" class="nav-link" aria-label="目录"><span class="font-icon icon iconfont icon-filter" style=""></span>目录<!----></a></li><li class="dropdown-item"><a href="/balabala/not_JustCode.html" class="nav-link" aria-label="其他一些知识"><span class="font-icon icon iconfont icon-engine" style=""></span>其他一些知识<!----></a></li><li class="dropdown-item"><a href="/balabala/TempCoder.html" class="nav-link" aria-label="临时堆砌的码"><span class="font-icon icon iconfont icon-template" style=""></span>临时堆砌的码<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/blogs/" class="nav-link" aria-label="博客日志"><span class="font-icon icon iconfont icon-blog" style=""></span>博客日志<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="计算机基础"><span class="title"><span class="font-icon icon iconfont icon-computer" style=""></span>计算机基础</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/CSBase/" class="nav-link" aria-label="目录"><span class="font-icon icon iconfont icon-filter" style=""></span>目录<!----></a></li><li class="dropdown-item"><a href="/CSBase/Nets/" class="nav-link" aria-label="计算机网络"><span class="font-icon icon iconfont icon-network" style=""></span>计算机网络<!----></a></li><li class="dropdown-item"><a href="/CSBase/OS/" class="nav-link" aria-label="操作系统"><span class="font-icon icon iconfont icon-OS" style=""></span>操作系统<!----></a></li></ul></button></div></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/Organic-Fish/Notes" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!----><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->C++ Template 进阶指南</h1><div class="page-info"><!----><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 95 分钟</span><meta property="timeRequired" content="PT95M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_1-1-c-另类简介-比你用的复杂-但比你想的简单" class="router-link-active router-link-exact-active toc-link level2">1.1. C++另类简介：比你用的复杂，但比你想的简单</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_1-2-适宜读者群" class="router-link-active router-link-exact-active toc-link level2">1.2. 适宜读者群</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_1-3-版权" class="router-link-active router-link-exact-active toc-link level2">1.3. 版权</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_1-4-推荐编译环境" class="router-link-active router-link-exact-active toc-link level2">1.4. 推荐编译环境</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_1-5-体例" class="router-link-active router-link-exact-active toc-link level2">1.5. 体例</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_1-5-1-示例代码" class="router-link-active router-link-exact-active toc-link level3">1.5.1. 示例代码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_1-5-2-引用" class="router-link-active router-link-exact-active toc-link level3">1.5.2. 引用</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_1-6-意见、建议、喷、补遗、写作计划" class="router-link-active router-link-exact-active toc-link level2">1.6. 意见、建议、喷、补遗、写作计划</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-1-什么是模板-template" class="router-link-active router-link-exact-active toc-link level2">2.1. 什么是模板(Template)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-2-类模板-class-template-的基本语法" class="router-link-active router-link-exact-active toc-link level2">2.2. 类模板 (Class Template) 的基本语法</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-2-1-模板类-还是-类模板" class="router-link-active router-link-exact-active toc-link level3">2.2.1. “模板类”还是“类模板”</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-2-2-class-template-的与成员变量定义" class="router-link-active router-link-exact-active toc-link level3">2.2.2. Class Template 的与成员变量定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-2-3-模板的使用" class="router-link-active router-link-exact-active toc-link level3">2.2.3. 模板的使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-2-4-类模板的成员函数定义" class="router-link-active router-link-exact-active toc-link level3">2.2.4. 类模板的成员函数定义</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-3-函数模板-function-tempalte-入门" class="router-link-active router-link-exact-active toc-link level2">2.3. 函数模板 (Function Tempalte) 入门</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-3-1-函数模板的声明和定义" class="router-link-active router-link-exact-active toc-link level3">2.3.1. 函数模板的声明和定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-3-2-函数模板的使用" class="router-link-active router-link-exact-active toc-link level3">2.3.2. 函数模板的使用</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-4-整型也可是-template-参数" class="router-link-active router-link-exact-active toc-link level2">2.4. 整型也可是 Template 参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_2-5-模板形式与功能是统一的" class="router-link-active router-link-exact-active toc-link level2">2.5. 模板形式与功能是统一的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-1-编程-元编程-模板元编程" class="router-link-active router-link-exact-active toc-link level2">3.1. 编程，元编程，模板元编程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-2-模板世界的-if-then-else-类模板的特化与偏特化" class="router-link-active router-link-exact-active toc-link level2">3.2. 模板世界的 If-Then-Else：类模板的特化与偏特化</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-2-1-根据类型执行代码" class="router-link-active router-link-exact-active toc-link level3">3.2.1. 根据类型执行代码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-2-2-特化" class="router-link-active router-link-exact-active toc-link level3">3.2.2. 特化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-2-3-特化-一些其它问题" class="router-link-active router-link-exact-active toc-link level3">3.2.3. 特化：一些其它问题</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-3-即用即推导" class="router-link-active router-link-exact-active toc-link level2">3.3. 即用即推导</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-3-1-视若无睹的语法错误" class="router-link-active router-link-exact-active toc-link level3">3.3.1. 视若无睹的语法错误</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-3-2-名称查找-i-am-who-i-am" class="router-link-active router-link-exact-active toc-link level3">3.3.2. 名称查找：I am who I am</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-3-3-多余的-typename-关键字" class="router-link-active router-link-exact-active toc-link level3">3.3.3. “多余的” typename 关键字</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_3-4-本章小结" class="router-link-active router-link-exact-active toc-link level2">3.4. 本章小结</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_4-1-正确的理解偏特化" class="router-link-active router-link-exact-active toc-link level2">4.1. 正确的理解偏特化</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_4-1-1-偏特化与函数重载的比较" class="router-link-active router-link-exact-active toc-link level3">4.1.1. 偏特化与函数重载的比较</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_4-1-2-不定长的模板参数" class="router-link-active router-link-exact-active toc-link level3">4.1.2. 不定长的模板参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_4-1-3-模板的默认实参" class="router-link-active router-link-exact-active toc-link level3">4.1.3. 模板的默认实参</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_4-2-后悔药-sfinae" class="router-link-active router-link-exact-active toc-link level2">4.2. 后悔药：SFINAE</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_4-3-concept-概念-对模板参数约束的直接描述" class="router-link-active router-link-exact-active toc-link level2">4.3. Concept “概念”：对模板参数约束的直接描述</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_4-3-1-概念-解决了什么问题" class="router-link-active router-link-exact-active toc-link level3">4.3.1. “概念” 解决了什么问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Language/wuye9036_CppTemplateTutorial.html#_4-3-2-概念-入门" class="router-link-active router-link-exact-active toc-link level3">4.3.2. &quot;概念&quot;入门</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="c-template-进阶指南" tabindex="-1"><a class="header-anchor" href="#c-template-进阶指南" aria-hidden="true">#</a> C++ Template 进阶指南 <!-- omit in toc --></h1><p>https://github.com/wuye9036/CppTemplateTutorial</p><p>章节目录由 VSCode 插件<a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one" target="_blank" rel="noopener noreferrer">Markdown All in One<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>生成。</p><ul><li><a href="#1-%E5%89%8D%E8%A8%80">1. 前言</a><ul><li><a href="#11-c%E5%8F%A6%E7%B1%BB%E7%AE%80%E4%BB%8B%E6%AF%94%E4%BD%A0%E7%94%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E4%BD%86%E6%AF%94%E4%BD%A0%E6%83%B3%E7%9A%84%E7%AE%80%E5%8D%95">1.1. C++另类简介：比你用的复杂，但比你想的简单</a></li><li><a href="#12-%E9%80%82%E5%AE%9C%E8%AF%BB%E8%80%85%E7%BE%A4">1.2. 适宜读者群</a></li><li><a href="#13-%E7%89%88%E6%9D%83">1.3. 版权</a></li><li><a href="#14-%E6%8E%A8%E8%8D%90%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83">1.4. 推荐编译环境</a></li><li><a href="#15-%E4%BD%93%E4%BE%8B">1.5. 体例</a><ul><li><a href="#151-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">1.5.1. 示例代码</a></li><li><a href="#152-%E5%BC%95%E7%94%A8">1.5.2. 引用</a></li></ul></li><li><a href="#16-%E6%84%8F%E8%A7%81%E5%BB%BA%E8%AE%AE%E5%96%B7%E8%A1%A5%E9%81%97%E5%86%99%E4%BD%9C%E8%AE%A1%E5%88%92">1.6. 意见、建议、喷、补遗、写作计划</a></li></ul></li><li><a href="#2-template-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">2. Template 的基本语法</a><ul><li><a href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BFtemplate">2.1. 什么是模板(Template)</a></li><li><a href="#22-%E7%B1%BB%E6%A8%A1%E6%9D%BF-class-template-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">2.2. 类模板 (Class Template) 的基本语法</a><ul><li><a href="#221-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E8%BF%98%E6%98%AF%E7%B1%BB%E6%A8%A1%E6%9D%BF">2.2.1. “模板类”还是“类模板”</a></li><li><a href="#222-class-template-%E7%9A%84%E4%B8%8E%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89">2.2.2. Class Template 的与成员变量定义</a></li><li><a href="#223-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8">2.2.3. 模板的使用</a></li><li><a href="#224-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">2.2.4. 类模板的成员函数定义</a></li></ul></li><li><a href="#23-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF-function-tempalte-%E5%85%A5%E9%97%A8">2.3. 函数模板 (Function Tempalte) 入门</a><ul><li><a href="#231-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89">2.3.1. 函数模板的声明和定义</a></li><li><a href="#232-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8">2.3.2. 函数模板的使用</a></li></ul></li><li><a href="#24-%E6%95%B4%E5%9E%8B%E4%B9%9F%E5%8F%AF%E6%98%AF-template-%E5%8F%82%E6%95%B0">2.4. 整型也可是 Template 参数</a></li><li><a href="#25-%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%BC%8F%E4%B8%8E%E5%8A%9F%E8%83%BD%E6%98%AF%E7%BB%9F%E4%B8%80%E7%9A%84">2.5. 模板形式与功能是统一的</a></li></ul></li><li><a href="#3-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80">3. 模板元编程基础</a><ul><li><a href="#31-%E7%BC%96%E7%A8%8B%E5%85%83%E7%BC%96%E7%A8%8B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B">3.1. 编程，元编程，模板元编程</a></li><li><a href="#32-%E6%A8%A1%E6%9D%BF%E4%B8%96%E7%95%8C%E7%9A%84-if-then-else%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96%E4%B8%8E%E5%81%8F%E7%89%B9%E5%8C%96">3.2. 模板世界的 If-Then-Else：类模板的特化与偏特化</a><ul><li><a href="#321-%E6%A0%B9%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81">3.2.1. 根据类型执行代码</a></li><li><a href="#322-%E7%89%B9%E5%8C%96">3.2.2. 特化</a></li><li><a href="#323-%E7%89%B9%E5%8C%96%E4%B8%80%E4%BA%9B%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98">3.2.3. 特化：一些其它问题</a></li></ul></li><li><a href="#33-%E5%8D%B3%E7%94%A8%E5%8D%B3%E6%8E%A8%E5%AF%BC">3.3. 即用即推导</a><ul><li><a href="#331-%E8%A7%86%E8%8B%A5%E6%97%A0%E7%9D%B9%E7%9A%84%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF">3.3.1. 视若无睹的语法错误</a></li><li><a href="#332-%E5%90%8D%E7%A7%B0%E6%9F%A5%E6%89%BEi-am-who-i-am">3.3.2. 名称查找：I am who I am</a></li><li><a href="#333-%E5%A4%9A%E4%BD%99%E7%9A%84-typename-%E5%85%B3%E9%94%AE%E5%AD%97">3.3.3. “多余的” typename 关键字</a></li></ul></li><li><a href="#34-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93">3.4. 本章小结</a></li></ul></li><li><a href="#4-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%89%B9%E5%8C%96%E4%B8%8E%E5%81%8F%E7%89%B9%E5%8C%96">4. 深入理解特化与偏特化</a><ul><li><a href="#41-%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3%E5%81%8F%E7%89%B9%E5%8C%96">4.1. 正确的理解偏特化</a><ul><li><a href="#411-%E5%81%8F%E7%89%B9%E5%8C%96%E4%B8%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E6%AF%94%E8%BE%83">4.1.1. 偏特化与函数重载的比较</a></li><li><a href="#412-%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0">4.1.2. 不定长的模板参数</a></li><li><a href="#413-%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82">4.1.3. 模板的默认实参</a></li></ul></li><li><a href="#42-%E5%90%8E%E6%82%94%E8%8D%AFsfinae">4.2. 后悔药：SFINAE</a></li><li><a href="#43-concept-%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%BA%A6%E6%9D%9F%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%8F%8F%E8%BF%B0">4.3. Concept “概念”：对模板参数约束的直接描述</a><ul><li><a href="#431-%E6%A6%82%E5%BF%B5-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">4.3.1. “概念” 解决了什么问题</a></li><li><a href="#432-%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8">4.3.2. &quot;概念&quot;入门</a></li></ul></li></ul></li><li><a href="#5-%E6%9C%AA%E5%AE%8C%E6%88%90%E7%AB%A0%E8%8A%82">5. 未完成章节</a></li></ul><h1 id="_1-前言" tabindex="-1"><a class="header-anchor" href="#_1-前言" aria-hidden="true">#</a> 1. 前言</h1><h2 id="_1-1-c-另类简介-比你用的复杂-但比你想的简单" tabindex="-1"><a class="header-anchor" href="#_1-1-c-另类简介-比你用的复杂-但比你想的简单" aria-hidden="true">#</a> 1.1. C++另类简介：比你用的复杂，但比你想的简单</h2><p>C++似乎从它为世人所知的那天开始便成为天然的话题性编程语言。在它在周围有着形形色色的赞美与贬低之词。当我在微博上透露欲写此文的意愿时，也收到了很多褒贬不一的评论。作为一门语言，能拥有这么多使用并恨着它、使用并畏惧它的用户，也算是语言丛林里的奇观了。</p><p>C++之所以变成一门层次丰富、结构多变、语法繁冗的语言，是有着多层次的原因的。Bjarne 在《The Design and Evolution of C++》一书中，详细的解释了 C++为什么会变成如今（C++98/03）的模样。这本书也是我和陈梓瀚一直对各位已经入门的新手强烈推荐的一本书。通过它你多少可以明白，C++的诸多语法要素之所以变成如今的模样，实属迫不得已。</p><p>模板作为 C++中最有特色的语言特性，它堪称玄学的语法和语义，理所应当的成为初学者的梦魇。甚至很多工作多年的人也对 C++的模板部分保有充分的敬畏。在多数的编码标准中，Template 俨然和多重继承一样，成为了一般程序员（非程序库撰写者）的禁区。甚至运用模板较多的 Boost，也成为了“众矢之的”。</p><p>但是实际上 C++模板远没有想象的那么复杂。我们只需要换一个视角：在 C++03 的时候，模板本身就可以独立成为一门“语言”。它有“值”，有“函数”，有“表达式”和“语句”。除了语法比较蹩脚外，它既没有指针也没有数组，更没有 C++里面复杂的继承和多态。可以说，它要比 C 语言要简单的多。如果我们把模板当做是一门语言来学习，那只需要花费学习 OO 零头的时间即可掌握。按照这样的思路，可以说在各种模板书籍中出现的多数技巧，都可以被轻松理解。</p><p>简单回顾一下模板的历史。87 年的时候，泛型（Generic Programming）便被纳入了 C++的考虑范畴，并直接导致了后来模板语法的产生。可以说模板语法一开始就是为了在 C++中提供泛型机制。92 年的时候，Alexander Stepanov 开始研究利用模板语法制作程序库，后来这一程序库发展成 STL，并在 93 年被接纳入标准中。</p><p>此时不少人以为 STL 已经是 C++模板的集大成之作，C++模板技止于此。但是在 95 年的《C++ Report》上，John Barton 和 Lee Nackman 提出了一个矩阵乘法的模板示例。可以说元编程在那个时候开始被很多人所关注。自此篇文章发表之后，很多大牛都开始对模板产生了浓厚的兴趣。其中对元编程技法贡献最大的当属 Alexandrescu 的《Modern C++ Design》及模板程序库 Loki。这一 2001 年发表的图书间接地导致了模板元编程库的出现。书中所使用的 Typelist 等泛型组件，和 Policy 等设计方法令人耳目一新。但是因为全书用的是近乎 Geek 的手法来构造一切设施，因此使得此书阅读起来略有难度。</p><p>2002 年出版的另一本书《C++ Templates》，可以说是在 Template 方面的集大成之作。它详细阐述了模板的语法、提供了和模板有关的语言细节信息，举了很多有代表性例子。但是对于模板新手来说，这本书细节如此丰富，让他们随随便便就打了退堂鼓缴械投降。</p><p>本文的写作初衷，就是通过“编程语言”的视角，介绍一个简单、清晰的“模板语言”。我会尽可能地将模板的诸多要素连串起来，用一些简单的例子帮助读者学习这门“语言”，让读者在编写、阅读模板代码的时候，能像 <code>if(exp) { dosomething(); }</code>一样的信手拈来，让“模板元编程”技术成为读者牢固掌握、可举一反三的有用技能。</p><h2 id="_1-2-适宜读者群" tabindex="-1"><a class="header-anchor" href="#_1-2-适宜读者群" aria-hidden="true">#</a> 1.2. 适宜读者群</h2><p>因为本文并不是用于 C++入门，例子中也多少会牵涉一些其它知识，因此如果读者能够具备以下条件，会读起来更加轻松：</p><ul><li>熟悉 C++的基本语法；</li><li>使用过 STL；</li><li>熟悉一些常用的算法，以及递归等程序设计方法。</li></ul><p>此外，尽管第一章会介绍一些 Template 的基本语法，但是还是会略显单薄。因此也希望读者能对 C++ Template 最基本语法形式有所了解和掌握；如果会编写基本的函数模板和类模板那就更好了。</p><p>诚如上节所述，本文并不是《C++ Templates》的简单重复，与《Modern C++ Design》交叠更少。从知识结构上，我建议大家可以先读本文，再阅读《C++ Templates》获取更丰富的语法与实现细节，以更进一步；《Modern C++ Design》除了元编程之外，还有很多的泛型编程示例，原则上泛型编程的部分与我所述的内容交叉不大，读者在读完 1-3 章了解模板的基本规则之后便可阅读《MCD》的相应章节；元编程部分（如 Typelist）建议在阅读完本文之后再行阅读，或许会更易理解。</p><h2 id="_1-3-版权" tabindex="-1"><a class="header-anchor" href="#_1-3-版权" aria-hidden="true">#</a> 1.3. 版权</h2><p>本文是随写随即同步到 Github 上，因此在行文中难免会遗漏引用。本文绝大部分内容应是直接承出我笔，但是也不定会有他山之石。所有指涉内容我会尽量以引号框记，或在上下文和边角注记中标示，如有遗漏烦请不吝指出。</p><p>全文所有为我所撰写的部分，作者均保留所有版权。如果有需要转帖或引用，还请注明出处并告知于我。</p><h2 id="_1-4-推荐编译环境" tabindex="-1"><a class="header-anchor" href="#_1-4-推荐编译环境" aria-hidden="true">#</a> 1.4. 推荐编译环境</h2><p>C++编译器众多，且对模板的支持可能存在细微差别。如果没有特别强调，本书行文过程中，使用了下列编译器来测试文中提供的代码和示例：</p><ul><li>Clang 14.0.3; 15.0 (amd64)</li><li>Visual Studio 2022 19.2+ (amd64)</li></ul><p>此外，部分复杂实例我们还在文中提供了在线的编译器预览以方便大家阅读和测试。在线编译器参见： <a href="https://gcc.godbolt.org/" target="_blank" rel="noopener noreferrer"><code>gcc.godbolt.org</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><p>一些示例中用到的特性所对应的 C++标准：</p><table><thead><tr><th>特性</th><th>标准</th></tr></thead><tbody><tr><td>std::decay_t&lt;T&gt;</td><td>C++ 14</td></tr></tbody></table><h2 id="_1-5-体例" tabindex="-1"><a class="header-anchor" href="#_1-5-体例" aria-hidden="true">#</a> 1.5. 体例</h2><h3 id="_1-5-1-示例代码" tabindex="-1"><a class="header-anchor" href="#_1-5-1-示例代码" aria-hidden="true">#</a> 1.5.1. 示例代码</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">SampleCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这是一段示例代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-2-引用" tabindex="-1"><a class="header-anchor" href="#_1-5-2-引用" aria-hidden="true">#</a> 1.5.2. 引用</h3><p>引用自 C++标准：</p><blockquote><p>1.1.2/1 这是一段引用或翻译自标准的文字</p></blockquote><p>引用自其他图书：</p><blockquote><p>《书名》 这是一段引用或翻译自其他图书的文字</p></blockquote><h2 id="_1-6-意见、建议、喷、补遗、写作计划" tabindex="-1"><a class="header-anchor" href="#_1-6-意见、建议、喷、补遗、写作计划" aria-hidden="true">#</a> 1.6. 意见、建议、喷、补遗、写作计划</h2><ul><li>需增加： <ul><li>模板的使用动机。</li><li>增加“如何使用本文”一节。本节将说明全书的体例（强调字体、提示语、例子的组织），所有的描述、举例、引用在重审时将按照体例要求重新组织。</li><li>除了用于描述语法的例子外，其他例子将尽量赋予实际意义，以方便阐述意图。</li><li>在合适的章节完整叙述模板的类型推导规则。Parameter-Argument, auto variable, decltype, decltype(auto)</li><li>在函数模板重载和实例化的部分讲述 ADL。</li><li>变参模板处应当按照标准（Argument Packing/Unpacking）来讲解。</li></ul></li><li>建议： <ul><li>比较模板和函数的差异性</li><li>蓝色：C++14 Return type deduction for normal functions 的分析</li></ul></li></ul><h1 id="_2-template-的基本语法" tabindex="-1"><a class="header-anchor" href="#_2-template-的基本语法" aria-hidden="true">#</a> 2. Template 的基本语法</h1><h2 id="_2-1-什么是模板-template" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是模板-template" aria-hidden="true">#</a> 2.1. 什么是模板(Template)</h2><h2 id="_2-2-类模板-class-template-的基本语法" tabindex="-1"><a class="header-anchor" href="#_2-2-类模板-class-template-的基本语法" aria-hidden="true">#</a> 2.2. 类模板 (Class Template) 的基本语法</h2><h3 id="_2-2-1-模板类-还是-类模板" tabindex="-1"><a class="header-anchor" href="#_2-2-1-模板类-还是-类模板" aria-hidden="true">#</a> 2.2.1. “模板类”还是“类模板”</h3><h3 id="_2-2-2-class-template-的与成员变量定义" tabindex="-1"><a class="header-anchor" href="#_2-2-2-class-template-的与成员变量定义" aria-hidden="true">#</a> 2.2.2. Class Template 的与成员变量定义</h3><p>我们来回顾一下最基本的 Class Template 声明和定义形式：</p><p>Class Template 声明：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Class Template 定义：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span>
<span class="token punctuation">{</span>
    T member<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>template</code> 是 C++关键字，意味着我们接下来将定义一个模板。和函数一样，模板也有一系列参数。这些参数都被囊括在 template 之后的<code>&lt; &gt;</code>中。在上文的例子中， <code>typename T</code>便是模板参数。回顾一下与之相似的函数参数的声明形式：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>T</code>则可以类比为函数形参<code>a</code>，这里的“模板形参”<code>T</code>，也同函数形参一样取成任何你想要的名字；<code>typename</code>则类似于例子中函数参数类型<code>int</code>，它表示模板参数中的<code>T</code>将匹配一个类型。除了 <code>typename</code> 之外，我们在后面还要讲到，整型也可以作为模板的参数。</p><p>在定义完模板参数之后，便可以定义你所需要的类。不过在定义类的时候，除了一般类可以使用的类型外，你还可以使用在模板参数中使用的类型 <code>T</code>。可以说，这个 <code>T</code>是模板的精髓，因为你可以通过指定模板实参，将 T 替换成你所需要的类型。</p><p>例如我们用<code>ClassA&lt;int&gt;</code>来实例化类模板 ClassA，那么<code>ClassA&lt;int&gt;</code>可以等同于以下的定义：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 注意：这并不是有效的C++语法，只是为了说明模板的作用</span>
<span class="token keyword">typedef</span> <span class="token keyword">class</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> member<span class="token punctuation">;</span>
<span class="token punctuation">}</span> ClassA<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，通过模板参数替换类型，可以获得很多形式相同的新类型，有效减少了代码量。这种用法，我们称之为“泛型”（Generic Programming），它最常见的应用，即是 STL 中的容器类模板。</p><h3 id="_2-2-3-模板的使用" tabindex="-1"><a class="header-anchor" href="#_2-2-3-模板的使用" aria-hidden="true">#</a> 2.2.3. 模板的使用</h3><p>对于 C++来说，类型最重要的作用之一就是用它去产生一个变量。例如我们定义了一个动态数组（列表）的类模板<code>vector</code>，它对于任意的元素类型都具有 push_back 和 clear 的操作，我们便可以如下定义这个类：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">vector</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span> elements<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们的程序需要一个整型和一个浮点型的列表，那么便可以通过以下代码获得两个变量：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> intArray<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> floatArray<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们就可以执行以下的操作，获得我们想要的结果：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>intArray<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
floatArray<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>变量定义的过程可以分成两步来看：第一步，<code>vector&lt;int&gt;</code>将<code>int</code>绑定到类模板<code>vector</code>上，获得了一个“普通的类<code>vector&lt;int&gt;</code>”；第二步通过<code>vector&lt;int&gt;</code>定义了一个变量。 与“普通的类”不同，类模板是不能直接用来定义变量的 —— 毕竟它的名字是“模板”而不是“类”。例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector unknownVector<span class="token punctuation">;</span> <span class="token comment">// 错误示例</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样就是错误的。我们把通过类型绑定将类模板变成“普通的类”的过程，称之为模板实例化（Template Instantiate）。实例化的语法是：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>模板名 <span class="token operator">&lt;</span> 模板实参<span class="token number">1</span> <span class="token punctuation">[</span>，模板实参<span class="token number">2</span>，<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>看几个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>
ClassA<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T0</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">ClassB</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Class body ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

ClassB<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，在实例化过程中，被绑定到模板参数上的类型（即模板实参）需要与模板形参正确匹配。 就如同函数一样，如果没有提供足够并匹配的参数，模板便不能正确的实例化。</p><h3 id="_2-2-4-类模板的成员函数定义" tabindex="-1"><a class="header-anchor" href="#_2-2-4-类模板的成员函数定义" aria-hidden="true">#</a> 2.2.4. 类模板的成员函数定义</h3><p>由于 C++11 正式废弃“模板导出”这一特性，因此在类模板的变量在调用成员函数的时候，需要看到完整的成员函数定义。因此现在的类模板中的成员函数，通常都是以内联的方式实现。 例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">vector</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Function body</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span> elements<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，我们也可以将<code>vector&lt;T&gt;::clear</code>的定义部分放在类型之外，只不过这个时候的语法就显得蹩脚许多：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">vector</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注意这里只有声明</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span> elements<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 函数的实现放在这里</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Function body</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数的实现部分看起来略微拗口。我第一次学到的时候，觉得</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> vector<span class="token double-colon punctuation">::</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Function body</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样不就行了吗？但是简单想就会知道，<code>clear</code>里面是找不到泛型类型<code>T</code>的符号的。</p><p>因此，在成员函数实现的时候，必须要提供模板参数。此外，为什么类型名不是<code>vector</code>而是<code>vector&lt;T&gt;</code>呢？ 如果你了解过模板的偏特化与特化的语法，应该能看出，这里的 <code>vector&lt;T&gt;</code> 在语法上类似于特化/偏特化。实际上，这里的函数定义也确实是成员函数的偏特化。特化和偏特化的概念，本文会在第二部分详细介绍。</p><p>综上，正确的成员函数实现如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">// 模板参数</span>
<span class="token keyword">void</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token comment">/*看起来像偏特化*/</span> <span class="token double-colon punctuation">::</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 函数的实现放在这里</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Function body</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-3-函数模板-function-tempalte-入门" tabindex="-1"><a class="header-anchor" href="#_2-3-函数模板-function-tempalte-入门" aria-hidden="true">#</a> 2.3. 函数模板 (Function Tempalte) 入门</h2><h3 id="_2-3-1-函数模板的声明和定义" tabindex="-1"><a class="header-anchor" href="#_2-3-1-函数模板的声明和定义" aria-hidden="true">#</a> 2.3.1. 函数模板的声明和定义</h3><p>函数模板的语法与类模板基本相同，也是以关键字<code>template</code>和模板参数列表作为声明与定义的开始。模板参数列表中的类型，可以出现在参数、返回值以及函数体中。比方说下面几个例子</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> U <span class="token function">foo</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    T var<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论是函数模板还是类模板，在实际代码中看起来都是“千变万化”的。这些“变化”，主要是因为类型被当做了参数，导致代码中可以变化的部分更多了。</p><p>归根结底，模板无外乎两点：</p><ol><li><p>函数或者类里面，有一些类型我们希望它能变化一下，我们用标识符来代替它，这就是“模板参数”；</p></li><li><p>在需要这些类型的地方，写上相对应的标识符（“模板参数”）。</p></li></ol><p>当然，这里的“可变”实际上在代码编译好后就固定下来了，可以称之为编译期的可变性。</p><p>这里多啰嗦一点，主要也是想告诉大家，模板其实是个很简单的东西。</p><p>下面这个例子，或许可以帮助大家解决以下两个问题：</p><ol><li><p>什么样的需求会使用模板来解决？</p></li><li><p>怎样把脑海中的“泛型”变成真正“泛型”的代码？</p></li></ol><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>举个例子：generic typed function ‘add’
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在我遇到的朋友中，即便如此对他解释了模板，即便他了解了模板，也仍然会对模板产生畏难情绪。毕竟从形式上来说，模板化的类和模板化的函数都要较非模板的版本更加复杂，阅读代码所需要理解的内容也有所增多。</p><p>如何才能克服这一问题，最终视模板如平坦代码呢？</p><p>答案只有一个：<strong>无他，唯手熟尔</strong>。</p><p>在学习模板的时候，要反复做以下的思考和练习：</p><ol><li><p>提出问题：我的需求能不能用模板来解决？</p></li><li><p>怎么解决？</p></li><li><p>把解决方案用代码写出来。</p></li><li><p>如果失败了，找到原因。是知识有盲点（例如不知道怎么将 <code>T&amp;</code> 转化成 <code>T</code>），还是不可行（比如试图利用浮点常量特化类模板，但实际上这样做是不可行的）？</p></li></ol><p>通过重复以上的练习，应该可以对模板的语法和含义都有所掌握。如果提出问题本身有困难，或许下面这个经典案例可以作为你思考的开始：</p><ol><li><p>写一个泛型的数据结构：例如，线性表，数组，链表，二叉树；</p></li><li><p>写一个可以在不同数据结构、不同的元素类型上工作的泛型函数，例如求和；</p></li></ol><p>当然和“设计模式”一样，模板在实际应用中，也会有一些固定的需求和解决方案。比较常见的场景包括：泛型（最基本的用法）、通过类型获得相应的信息（型别萃取）、编译期间的计算、类型间的推导和变换（从一个类型变换成另外一个类型，比如 boost::function）。这些本文在以后的章节中会陆续介绍。</p><h3 id="_2-3-2-函数模板的使用" tabindex="-1"><a class="header-anchor" href="#_2-3-2-函数模板的使用" aria-hidden="true">#</a> 2.3.2. 函数模板的使用</h3><p>我们先来看一个简单的函数模板，两个数相加：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">Add</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数模板的调用格式是：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>函数模板名 <span class="token operator">&lt;</span> 模板参数列表 <span class="token operator">&gt;</span> <span class="token punctuation">(</span> 参数 <span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如，我们想对两个 <code>int</code> 求和，那么套用类的模板实例化方法，我们可以这么写：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时我们等于拥有了一个新函数：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token generic-function"><span class="token function">Add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时在另外一个偏远的程序角落，你也需要求和。而此时你的参数类型是 <code>float</code> ，于是你写下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token generic-function"><span class="token function">Add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一切看起来都很完美。但如果你具备程序员的最佳美德——懒惰——的话，你肯定会这样想，我在调用 <code>Add&lt;int&gt;(a, b)</code> 的时候， <code>a</code> 和 <code>b</code> 匹配的都是那个 <code>T</code>。编译器就应该知道那个 <code>T</code> 实际上是 <code>int</code> 呀？为什么还要我多此一举写 <code>Add&lt;int&gt;</code> 呢？ 唔，我想说的是，编译器的作者也是这么想的。所以实际上你在编译器里面写下以下片段：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会心领神会地将 <code>Add</code> 变成 <code>Add&lt;int&gt;</code>。但是编译器不能面对模棱两可的答案。比如你这么写的话呢？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span>  a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span>  result <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个参数 <code>a</code> 告诉编译器，这个 <code>T</code> 是 <code>int</code>。编译器点点头说，好。但是第二个参数 <code>b</code> 不高兴了，告诉编译器说，你这个 <code>T</code>，其实是 <code>char</code>。 两个参数各自指导 <code>T</code> 的类型，编译器就不知道怎么做了。在 Visual Studio 2012 下，会有这样的提示：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>error C2782: &#39;T _1_2_2::Add(T,T)&#39; : template parameter &#39;T&#39; is ambiguous
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>好吧，&quot;ambiguous&quot;，这个提示再明确不过了。</p><p>不过，只要你别逼得编译器精神分裂的话，编译器其实是非常聪明的，它可以从很多的蛛丝马迹中，猜测到你真正的意图，有如下面的例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">foo</span><span class="token punctuation">(</span> A<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>

A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 它能准确地猜到 T 是 int.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>咦，编译器居然绕过了 A 这个外套，猜到了 <code>T</code> 匹配的是 <code>int</code>。编译器是怎么完成这一“魔法”的，我们暂且不表，2.2 节时再和盘托出。</p><p>下面轮到你的练习时间了。你试着写了很多的例子，但是其中一个你还是犯了疑惑：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">float</span> data<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 出错了！</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 也出错了！</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么会出错呢？你仔细想了想，原来编译器是没办法去根据返回值推断类型的。函数调用的时候，返回值被谁接受还不知道呢。如下修改后，就一切正常了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token generic-function"><span class="token function">GetValue</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token generic-function"><span class="token function">GetValue</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，是不是 so easy 啊？嗯，你又信心满满的做了一个练习：</p><p>你要写一个函数模板叫 <code>c_style_cast</code>，顾名思义，执行的是 C 风格的转换。然后出于方便起见，你希望它能和 <code>static_cast</code> 这样的内置转换有同样的写法。于是你写了一个 use case。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>DstT dest <span class="token operator">=</span> <span class="token generic-function"><span class="token function">c_style_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>DstT<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据调用形式你知道了，有 <code>DstT</code> 和 <code>SrcT</code> 两个模板参数。参数只有一个， <code>src</code>，所以函数的形参当然是这么写了： <code>(SrcT src)</code>。实现也很简单， <code>(DstT)v</code>。</p><p>我们把手上得到的信息来拼一拼，就可以编写自己的函数模板了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">SrcT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DstT</span><span class="token operator">&gt;</span> DstT <span class="token function">c_style_cast</span><span class="token punctuation">(</span>SrcT v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>DstT<span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> i <span class="token operator">=</span> <span class="token generic-function"><span class="token function">c_style_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，很 Easy 嘛！我们 F6 一下…咦！这是什么意思！</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>error C2783<span class="token operator">:</span> <span class="token char">&#39;DstT _1_2_2::c_style_cast(SrcT)&#39;</span> <span class="token operator">:</span> could <span class="token operator">not</span> deduce <span class="token keyword">template</span> argument <span class="token keyword">for</span> <span class="token char">&#39;DstT&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后你仔细的比较了一下，然后发现 … 模板参数有两个，而参数里面能得到的只有 <code>SrcT</code> 一个。结合出错信息看来关键在那个 <code>DstT</code> 上。这个时候，你死马当活马医，把模板参数写完整了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">float</span> i <span class="token operator">=</span> <span class="token generic-function"><span class="token function">c_style_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>嗯，很顺利的通过了。难道 C++不能支持让参数推导一部分模板参数吗？</p><p>当然是可以的。只不过在部分推导、部分指定的情况下，编译器对模板参数的顺序是有限制的：<strong>先写需要指定的模板参数，再把能推导出来的模板参数放在后面</strong>。</p><p>在这个例子中，能推导出来的是 <code>SrcT</code>，需要指定的是 <code>DstT</code>。把函数模板写成下面这样就可以了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">DstT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">SrcT</span><span class="token operator">&gt;</span> DstT <span class="token function">c_style_cast</span><span class="token punctuation">(</span>SrcT v<span class="token punctuation">)</span>	<span class="token comment">// 模板参数 DstT 需要人肉指定，放前面。</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>DstT<span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> i <span class="token operator">=</span> <span class="token generic-function"><span class="token function">c_style_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 形象地说，DstT会先把你指定的参数吃掉，剩下的就交给编译器从函数参数列表中推导啦。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-4-整型也可是-template-参数" tabindex="-1"><a class="header-anchor" href="#_2-4-整型也可是-template-参数" aria-hidden="true">#</a> 2.4. 整型也可是 Template 参数</h2><p>模板参数除了类型外（包括基本类型、结构、类类型等），也可以是一个整型数（Integral Number）。这里的整型数比较宽泛，包括布尔型，不同位数、有无符号的整型，甚至包括指针。我们将整型的模板参数和类型作为模板参数来做一个对比：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TemplateWithType</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span>      V<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TemplateWithValue</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我想这个时候你也更能理解 <code>typename</code> 的意思了：它相当于是模板参数的“类型”，告诉你 <code>T</code> 是一个 <code>typename</code>。</p><p>按照 C++ Template 最初的想法，模板不就是为了提供一个类型安全、易于调试的宏吗？有类型就够了，为什么要引入整型参数呢？考虑宏，它除了代码替换，还有一个作用是作为常数出现。所以整型模板参数最基本的用途，也是定义一个常数。例如这段代码的作用：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">int</span> Size<span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">Array</span>
<span class="token punctuation">{</span>
    T data<span class="token punctuation">[</span>Size<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token operator">&gt;</span> arr<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>便相当于下面这段代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">IntArrayWithSize16</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// int 替换了 T, 16 替换了 Size</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

IntArrayWithSize16 arr<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中有一点需要注意，因为模板的匹配是在编译的时候完成的，所以实例化模板的时候所使用的参数，也必须要在编译期就能确定。例如以下的例子编译器就会报错：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> i<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    A<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span> <span class="token comment">// 正确！</span>
    A<span class="token operator">&lt;</span>x<span class="token operator">&gt;</span> b<span class="token punctuation">;</span> <span class="token comment">// error C2971: &#39;_1_3::A&#39; : template parameter &#39;i&#39; : &#39;x&#39; : a local variable cannot be used as a non-type argument</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 x 不是一个编译期常量，所以 <code>A&lt;x&gt;</code> 就会告诉你，x 是一个局部变量，不能作为一个模板参数出现。</p><p>嗯，这里我们再来写几个相对复杂的例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> i<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">uint8_t</span> a<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">b</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> c<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>A<span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> i<span class="token operator">&gt;</span> <span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>	<span class="token comment">// 当然也能用于函数模板</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>
    B<span class="token operator">&lt;</span><span class="token number">7</span><span class="token punctuation">,</span> A<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token operator">&gt;</span>	b<span class="token punctuation">;</span> <span class="token comment">// 模板参数可以是一个无符号八位整数，可以是模板生成的类；可以是一个指针。</span>
    C<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>foo<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>      <span class="token comment">// 模板参数可以是一个bool类型的常量，甚至可以是一个函数指针。</span>
    D<span class="token operator">&lt;</span><span class="token operator">&amp;</span>A<span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>foo<span class="token operator">&gt;</span> d<span class="token punctuation">;</span>       <span class="token comment">// 丧心病狂啊！它还能是一个成员函数指针！</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// x == 8。因为整型模板参数无法从函数参数获得，所以只能是手工指定啦。</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">float</span> a<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ERROR: 别闹！早说过只能是整数类型的啦！</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，除了单纯的用作常数之外，整型参数还有一些其它的用途。这些“其它”用途最重要的一点是让类型也可以像整数一样运算。《Modern C++ Design》给我们展示了很多这方面的例子。不过你不用急着去阅读那本天书，我们会在做好足够的知识铺垫后，让你轻松学会这些招数。</p><h2 id="_2-5-模板形式与功能是统一的" tabindex="-1"><a class="header-anchor" href="#_2-5-模板形式与功能是统一的" aria-hidden="true">#</a> 2.5. 模板形式与功能是统一的</h2><p>第一章走马观花的带着大家复习了一下 C++ Template 的基本语法形式，也解释了包括 <code>typename</code> 在内，类/函数模板写法中各个语法元素的含义。形式是功能的外在体现，介绍它们也是为了让大家能理解到，模板之所以写成这种形式是有必要的，而不是语言的垃圾成分。</p><p>从下一章开始，我们便进入了更加复杂和丰富的世界：讨论模板的匹配规则。其中有令人望而生畏的特化与偏特化。但是，请相信我们在序言中所提到的：将模板作为一门语言来看待，它会变得有趣而简单。</p><h1 id="_3-模板元编程基础" tabindex="-1"><a class="header-anchor" href="#_3-模板元编程基础" aria-hidden="true">#</a> 3. 模板元编程基础</h1><h2 id="_3-1-编程-元编程-模板元编程" tabindex="-1"><a class="header-anchor" href="#_3-1-编程-元编程-模板元编程" aria-hidden="true">#</a> 3.1. 编程，元编程，模板元编程</h2><p>技术的学习是一个登山的过程。第一章是最为平坦的山脚道路。而从这一章开始，则是正式的爬坡。无论是我写作还是你阅读，都需要付出比第一章更多的代价。那么问题就是，付出更多的精力学习模板是否值得？</p><p>这个问题很功利，但是一针见血。因为技术的根本目的在于解决需求。那 C++的模板能做什么？</p><p>一个高（树）大（新）上（风）的回答是，C++里面的模板，犹如 C 中的宏、C 和 Java 中的自省（restropection）和反射（reflection），是一个改变语言内涵，拓展语言外延的存在。</p><p>程序最根本的目的是什么？复现真实世界或人所构想的规律，减少重复工作的成本，或通过提升规模完成人所不能及之事。但是世间之事万千，有限的程序如何重现复杂的世界呢？</p><p>答案是“抽象”。论及具体手段，无外乎“求同”与“存异”：概括一般规律，处理特殊情况。这也是软件工程所追求的目标。一般规律概括的越好，我们所付出的劳动也就越少。</p><p>同样的，作为脑力劳动的产品，程序本身也是有规律性的。《Modern C++ Design》中的前言就抛出了一连串有代表性的问题：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>如何撰写更高级的C++程式？
如何应付即使在很干净的设计中仍然像雪崩一样的不相干细节？
如何构建可复用组件，使得每次在不同程式中应用组件时无需大动干戈？
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们以数据结构举例。在程序里，你需要一些堆栈。这个堆栈的元素可能是整数、浮点或者别的什么类型。一份整型堆栈的代码可能是：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">StackInt</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... 其他代码 ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你要支持浮点了，那么你只能将代码再次拷贝出来，并作如下修改：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">StackFloat</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">float</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... 其他代码 ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然也许你觉得这样做能充分体会代码行数增长的成就感。但是有一天，你突然发现：呀，<code>Find</code> 函数实现有问题了。怎么办？这个时候也许你只有两份这样的代码，那好说，一一去修正就好了。如果你有十个呢？二十个？五十个？</p><p>时间一长，你就厌倦了这样的生活。你觉得每个堆栈都差不多，但是又有点不一样。为了这一点点不一样，你付出了太多的时间。吃饭的时间，泡妞的时间，睡觉的时间，看岛国小电影顺便练习小臂力量的时间。</p><p>于是便诞生了新的技术，来消解我们的烦恼。</p><p>这个技术的名字，并不叫“模板”，而是叫“元编程”。</p><p>元（meta）无论在中文还是英文里，都是个很“抽象（abstract）”的词。因为它的本意就是“抽象”。元编程，也可以说就是“编程的抽象”。用更好理解的说法，元编程意味着你撰写一段程序 A，程序 A 会运行后生成另外一个程序 B，程序 B 才是真正实现功能的程序。那么这个时候程序 A 可以称作程序 B 的元程序，撰写程序 A 的过程，就称之为“元编程”。</p><p>回到我们的堆栈的例子。真正执行功能的，其实仍然是浮点的堆栈、整数的堆栈、各种你所需要的类型的堆栈。但是因为这些堆栈之间太相似了，仅仅有着些微的不同，我们为什么不能有一个将相似之处囊括起来，同时又能分别体现出不同之处的程序呢？很多语言都提供了这样的机会。C 中的宏，C++中的模板，Python 中的 Duck Typing，广义上将都能够实现我们的思路。</p><p>我们的目的，是找出程序之间的相似性，进行“元编程”。而在 C++中，元编程的手段，可以是宏，也可以是模板。</p><p>宏的例子姑且不论，我们来看一看模板：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Stack</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    T <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... 其他代码 ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> Stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>   StackInt<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> Stack<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> StackFloat<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过模板，我们可以将形形色色的堆栈代码分为两个部分，一个部分是不变的接口，以及近乎相同的实现；另外一部分是元素的类型，它们是需要变化的。因此同函数类似，需要变化的部分，由模板参数来反映；不变的部分，则是模板内的代码。可以看到，使用模板的代码，要比不使用模板的代码简洁许多。</p><p>如果元编程中所有变化的量（或者说元编程的参数），都是类型，那么这样的编程，我们有个特定的称呼，叫“泛型”。</p><p>但是你会问，模板的发明，仅仅是为了做和宏几乎一样的替换工作吗？可以说是，也可以说不是。一方面，很多时候模板就是为了替换类型，这个时候作用上其实和宏没什么区别。只是宏是基于文本的替换，被替换的文本本身没有任何语义。只有替换完成，编译器才能进行接下来的处理。而模板会在分析模板时以及实例化模板时时候都会进行检查，而且源代码中也能与调试符号一一对应，所以无论是编译时还是运行时，排错都相对简单。</p><p>但是模板和宏也有很大的不同，否则此文也就不能成立了。模板最大的不同在于它是“可以运算”的。我们来举一个例子，不过可能有点牵强。考虑我们要写一个向量逐分量乘法。只不过这个向量，它非常的大。所以为了保证速度，我们需要使用 SIMD 指令进行加速。假设我们有以下指令可以使用：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code>Int8<span class="token punctuation">,</span><span class="token key atrule">16</span><span class="token punctuation">:</span> N/A
<span class="token key atrule">Int32</span><span class="token punctuation">:</span> VInt32Mul(int32x4<span class="token punctuation">,</span> int32x4)
<span class="token key atrule">Int64</span><span class="token punctuation">:</span> VInt64Mul(int64x4<span class="token punctuation">,</span> int64x4)
<span class="token key atrule">Float</span><span class="token punctuation">:</span> VInt64Mul(floatx2<span class="token punctuation">,</span> floatx2)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以对于 Int8 和 Int16，我们需要提升到 Int32，而 Int32 和 Int64，各自使用自己的指令。所以我们需要实现下的逻辑：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span>v4a<span class="token punctuation">,</span> v4b <span class="token operator">:</span> vectorsA<span class="token punctuation">,</span> vectorsB<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> type is Int8<span class="token punctuation">,</span> Int16
        <span class="token function">VInt32Mul</span><span class="token punctuation">(</span> <span class="token function">ConvertToInt32</span><span class="token punctuation">(</span>v4a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ConvertToInt32</span><span class="token punctuation">(</span>v4b<span class="token punctuation">)</span> <span class="token punctuation">)</span>
    elif type is Int32
        <span class="token function">VInt32Mul</span><span class="token punctuation">(</span> v4a<span class="token punctuation">,</span> v4b <span class="token punctuation">)</span>
    elif type is Float
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的问题就在于，如何根据 <code>type</code> 分别提供我们需要的实现？这里有两个难点。首先， <code>if(type == xxx) {}</code> 是不存在于 C++中的。第二，即便存在根据 <code>type</code> 的分配方法，我们也不希望它在运行时 branch，这样会变得很慢。我们希望它能按照类型直接就把代码编译好，就跟直接写的一样。</p><p>嗯，聪明你果然想到了，重载也可以解决这个问题。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token function">GenericMul</span><span class="token punctuation">(</span>int8x4<span class="token punctuation">,</span>  int8x4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">GenericMul</span><span class="token punctuation">(</span>int16x4<span class="token punctuation">,</span> int16x4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">GenericMul</span><span class="token punctuation">(</span>int32x4<span class="token punctuation">,</span> int32x4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">GenericMul</span><span class="token punctuation">(</span>int64x4<span class="token punctuation">,</span> int64x4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 其它 Generic Mul ...</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>v4a<span class="token punctuation">,</span> v4b <span class="token operator">:</span> vectorsA<span class="token punctuation">,</span> vectorsB<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">GenericMul</span><span class="token punctuation">(</span>v4a<span class="token punctuation">,</span> v4b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样不就可以了吗？</p><p>唔，你赢了，是这样没错。但是问题是，我这个平台是你可没见过，它叫 <code>Deep Thought</code>， 特别缺心眼儿，不光有 <code>int8</code>，还有更奇怪的 <code>int9</code>, <code>int11</code>，以及可以代表世间万物的 <code>int42</code>。你总不能为之提供所有的重载吧？这简直就像你枚举了所有程序的输入，并为之提供了对应的输出一样。</p><p>好吧，我承认这个例子还是太牵强了。不过相信我，在你阅读完第二章和第三章之后，你会将这些特性自如地运用到你的程序之中。你的程序将会变成体现模板“可运算”威力的最好例子。</p><h2 id="_3-2-模板世界的-if-then-else-类模板的特化与偏特化" tabindex="-1"><a class="header-anchor" href="#_3-2-模板世界的-if-then-else-类模板的特化与偏特化" aria-hidden="true">#</a> 3.2. 模板世界的 If-Then-Else：类模板的特化与偏特化</h2><h3 id="_3-2-1-根据类型执行代码" tabindex="-1"><a class="header-anchor" href="#_3-2-1-根据类型执行代码" aria-hidden="true">#</a> 3.2.1. 根据类型执行代码</h3><p>前一节的示例提出了一个要求：需要做出根据类型执行不同代码。要达成这一目的，模板并不是唯一的途径。比如之前我们所说的重载。如果把眼界放宽一些，虚函数也是根据类型执行代码的例子。此外，在 C 语言时代，也会有一些技法来达到这个目的，比如下面这个例子，我们需要对两个浮点做加法， 或者对两个整数做乘法：</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>struct Variant
{
    union
    {
        int x;
        float y;
    } data;
    uint32 typeId;
};

Variant addFloatOrMulInt(Variant const* a, Variant const* b)
{
    Variant ret;
    assert(a-&gt;typeId == b-&gt;typeId);
    if (a-&gt;typeId == TYPE_INT)
    {
        ret.x = a-&gt;x * b-&gt;x;
    }
    else
    {
        ret.y = a-&gt;y + b-&gt;y;
    }
    return ret;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更常见的是 <code>void*</code>:</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>define <span class="token function">BIN_OP</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> a<span class="token punctuation">,</span> op<span class="token punctuation">,</span> b<span class="token punctuation">,</span> result<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>type <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>type <span class="token keyword">const</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">op</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>type <span class="token keyword">const</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">doDiv</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> out<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token keyword">const</span><span class="token operator">*</span> data0<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token keyword">const</span><span class="token operator">*</span> data1<span class="token punctuation">,</span> DATA_TYPE type<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> TYPE_INT<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">BIN_OP</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> data0<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> data1<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">BIN_OP</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">,</span> data0<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">,</span> data1<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 C++中比如在 <code>Boost.Any</code> 的实现中，运用了 <code>typeid</code> 来查询类型信息。和 <code>typeid</code> 同属于 RTTI 机制的 <code>dynamic_cast</code>，也经常会用来做类型判别的工作。我想你应该写过类似于下面的代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>IAnimal<span class="token operator">*</span> animal <span class="token operator">=</span> <span class="token function">GetAnimalFromSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

IDog<span class="token operator">*</span> maybeDog <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>IDog<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>maybeDog<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    maybeDog<span class="token operator">-&gt;</span><span class="token function">Wangwang</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
ICat<span class="token operator">*</span> maybeCat <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ICat<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>maybeCat<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    maybeCat<span class="token operator">-&gt;</span><span class="token function">Moemoe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，在实际的工作中，我们建议把需要 <code>dynamic_cast</code> 后执行的代码，尽量变成虚函数。不过这个已经是另外一个问题了。我们看到，不管是哪种方法都很难避免 <code>if</code> 的存在。而且因为输入数据的类型是模糊的，经常需要强制地、没有任何检查的转换成某个类型，因此很容易出错。</p><p>但是模板与这些方法最大的区别并不在这里。模板无论其参数或者是类型，它都是一个编译期分派的办法。编译期就能确定的东西既可以做类型检查，编译器也能进行优化，砍掉任何不必要的代码执行路径。例如在上例中，</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">addFloatOrMulInt</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 迷之代码1：用于T是float的情况</span>

<span class="token comment">// 迷之代码2：用于T是int时的情况</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你运用了模板来实现，那么当传入两个不同类型的变量，或者不是 <code>int</code> 和 <code>float</code> 变量，编译器就会提示错误。但是如果使用了我们前述的 <code>Variant</code> 来实现，编译器可就管不了那么多了。但是，成也编译期，败也编译期。最严重的“缺点”，就是你没办法根据用户输入或者别的什么在运行期间可能发生变化的量来决定它产生、或执行什么代码。比如下面的代码段，它是不成立的。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cin <span class="token operator">&gt;&gt;</span> x <span class="token operator">&gt;&gt;</span> y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span>x<span class="token punctuation">,</span> y<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这点限制也粉碎了妄图用模板来包办工厂（Factory）甚至是反射的梦想。尽管在《Modern C++ Design》中（别问我为什么老举这本书，因为《C++ Templates》和《Generic Programming》我只是囫囵吞枣读过，基本不记得了)大量运用模板来简化工厂方法；同时 C++11/14 中的一些机制如 Variadic Template 更是让这一问题的解决更加彻底。但无论如何，直到 C++11/14，光靠模板你就是写不出依靠类名或者 ID 变量产生类型实例的代码。</p><p>所以说，从能力上来看，模板能做的事情都是编译期完成的。编译期完成的意思就是，当你编译一个程序的时候，所有的量就都已经确定了。比如下面的这个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
Variant aVar<span class="token punctuation">,</span> bVar<span class="token punctuation">;</span>
aVar<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 我们新加上的方法，怎么实现的无所谓，大家明白意思就行了。</span>
bVar<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
Variant result <span class="token operator">=</span> <span class="token function">addFloatOrMulInt</span><span class="token punctuation">(</span>aVar<span class="token punctuation">,</span> bVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除非世界末日，否则这个例子里不管你怎么蹦跶，单看代码我们就能知道， <code>aVar</code> 和 <code>bVar</code> 都一定会是整数。所以如果有合适的机制，编译器就能知道此处的 <code>addFloatOrMulInt</code> 中只需要执行 <code>Int</code> 路径上的代码，而且编译器在此处也能单独为 <code>Int</code> 路径生成代码，从而去掉那个不必要的 <code>if</code>。</p><p>在模板代码中，这个“合适的机制”就是指“特化”和“部分特化（Partial Specialization）”，后者也叫“偏特化”。</p><h3 id="_3-2-2-特化" tabindex="-1"><a class="header-anchor" href="#_3-2-2-特化" aria-hidden="true">#</a> 3.2.2. 特化</h3><p>我的高中物理老师对我说过一句令我受用至今的话：把自己能做的事情做好。编写模板程序也是一样。当你试图用模板解决问题之前，先撇开那些复杂的语法要素，用最直观的方式表达你的需求：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 这里是伪代码，意思一下</span>

<span class="token keyword">int</span><span class="token operator">|</span><span class="token keyword">float</span> <span class="token function">addFloatOrMulInt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>type is Int<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type is Float<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token function">addFloatOrMulInt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// c = a + b;</span>

    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token function">addFloatOrMulInt</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// z = x * y;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为这一节是讲类模板有关的特化和偏特化机制，所以我们不用普通的函数，而是用类的静态成员函数来做这个事情（这就是典型的没事找抽型）：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 这里仍然是伪代码，意思一下，too。</span>
<span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token operator">|</span><span class="token keyword">float</span> <span class="token function">Do</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>type is Int<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type is Float<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
	    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c = a + b;</span>

    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// z = x * y;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好，意思表达清楚了。我们先从调用方的角度，把这个形式改写一下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c = a + b;</span>

    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// z = x * y;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也许你不明白为什么要改写成现在这个样子。看不懂不怪你，怪我讲得不好。但是你别急，先看看这样改写以后能不能跟我们的目标接近一点。如果我们把 <code>AddFloatOrMulInt&lt;float&gt;::Do</code> 看作一个普通的函数，那么我们可以写两个实现出来：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">float</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">,</span> <span class="token keyword">float</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c = a + b;</span>

    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// z = x * y;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样是不是就很开心了？我们更进一步，把 <code>AddFloatOrMulInt&lt;int&gt;::Do</code> 换成合法的类模板：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 这个是给float用的。</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span>
<span class="token punctuation">{</span>
    T <span class="token function">Do</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 这个是给int用的。</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span>
<span class="token punctuation">{</span>
    T <span class="token function">Do</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>

    <span class="token comment">// 嗯，我们需要 c = a + b;</span>
    c <span class="token operator">=</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... 觉得哪里不对劲 ...</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 啊！有两个AddFloatOrMulInt，class看起来一模一样，要怎么区分呢！</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好吧，问题来了！如何要让两个内容不同，但是模板参数形式相同的类进行区分呢？特化！特化（specialization）是根据一个或多个特殊的整数或类型，给出模板实例化时的一个指定内容。我们先来看特化是怎么应用到这个问题上的。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 首先，要写出模板的一般形式（原型）</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 在这个例子里面一般形式里面是什么内容不重要，因为用不上</span>
        <span class="token comment">// 这里就随便给个0吧。</span>
        <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 其次，我们要指定T是int时候的代码，这就是特化：</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token comment">//</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 再次，我们要指定T是float时候的代码：</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">float</span> <span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">,</span> <span class="token keyword">float</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 这里面就不写了</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们再把特化的形式拿出来一瞧：这货有点怪啊： <code>template &lt;&gt; class AddFloatOrMulInt&lt;int&gt;</code>。别急，我给你解释一下。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 我们这个模板的基本形式是什么？</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token punctuation">;</span>

<span class="token comment">// 但是这个类，是给T是Int的时候用的，于是我们写作</span>
<span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// 当然，这里编译是通不过的。</span>

<span class="token comment">// 但是它又不是个普通类，而是类模板的一个特化（特例）。</span>
<span class="token comment">// 所以前面要加模板关键字template，</span>
<span class="token comment">// 以及模板参数列表</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token comment">/* 这里要填什么？ */</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// 最后，模板参数列表里面填什么？因为原型的T已经被int取代了。所以这里就不能也不需要放任何额外的参数了。</span>
<span class="token comment">// 所以这里放空。</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">AddFloatOrMulInt</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ... 针对Int的实现 ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Bingo!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哈，这样就好了。我们来做一个练习。我们有一些类型，然后你要用模板做一个对照表，让类型对应上一个数字。我先来做一个示范：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">uint8_t</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后呢，你的任务就是，要所有无符号的整数类型的特化（其实就是<code>uint8_t</code>到<code>uint64_t</code>啦），把所有的基本类型都赋予一个 ID（当然是不一样的啦）。当你做完后呢，可以把类型所对应的 ID 打印出来，我仍然以 <code>uint8_t</code> 为例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">PrintID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ID of uint8_t: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">uint8_t</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，看起来挺简单的，是吧。但是这里透露出了一个非常重要的信号，我希望你已经能察觉出来了： <code>TypeToID</code> 如同是一个函数。这个函数只能在编译期间执行。它输入一个类型，输出一个 ID。</p><p>如果你体味到了这一点，那么恭喜你，你的模板元编程已经开悟了。</p><h3 id="_3-2-3-特化-一些其它问题" tabindex="-1"><a class="header-anchor" href="#_3-2-3-特化-一些其它问题" aria-hidden="true">#</a> 3.2.3. 特化：一些其它问题</h3><p>在上一节结束之后，你一定做了许多的练习。我们再来做三个练习。第一，给<code>float</code>一个 ID；第二，给<code>void*</code>一个 ID；第三，给任意类型的指针一个 ID。先来做第一个:</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ...</span>
<span class="token comment">// TypeToID 的模板“原型”</span>
<span class="token comment">// ...</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token number">0xF10A7</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯， 这个你已经了然于心了。那么<code>void*</code>呢？你想了想，这已经是一个复合类型了。不错你还是战战兢兢地写了下来：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token number">0x401d</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">PrintID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ID of uint8_t: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遍译运行一下，对了。模板不过如此嘛。然后你觉得自己已经完全掌握了，并试图将所有 C++类型都放到模板里面，开始了自我折磨的过程：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">ClassB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>      <span class="token comment">// 函数的TypeID</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>       <span class="token comment">// 数组的TypeID</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 这是以数组为参数的函数的TypeID</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token punctuation">(</span>ClassB<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 我也不知道这是什么了，自己看着办吧。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>甚至连 <code>const</code> 和 <code>volatile</code> 都能装进去：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> <span class="token keyword">volatile</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">volatile</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时就很明白了，只要 <code>&lt;&gt;</code> 内填进去的是一个 C++能解析的合法类型，模板都能让你特化。不过这个时候如果你一点都没有写错的话， <code>PrintID</code> 中只打印了我们提供了特化的类型的 ID。那如果我们没有为之提供特化的类型呢？比如说 double？OK，实践出真知，我们来尝试着运行一下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">PrintID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ID of double: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，它输出的是-1。我们顺藤摸瓜会看到， <code>TypeToID</code>的类模板“原型”的 ID 是值就是-1。通过这个例子可以知道，当模板实例化时提供的模板参数不能匹配到任何的特化形式的时候，它就会去匹配类模板的“原型”形式。</p><p>不过这里有一个问题要理清一下。和继承不同，类模板的“原型”和它的特化类在实现上是没有关系的，并不是在类模板中写了 <code>ID</code> 这个 Member，那所有的特化就必须要加入 <code>ID</code> 这个 Member，或者特化就自动有了这个成员。完全没这回事。我们把类模板改成以下形式，或许能看的更清楚一点：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> NotID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">PrintID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ID of float: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment">// Print &quot;1&quot;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;NotID of float: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>NotID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// Error! TypeToID&lt;float&gt;使用的特化的类，这个类的实现没有NotID这个成员。</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ID of double: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token comment">// Error! TypeToID&lt;double&gt;是由类模板实例化出来的，它只有NotID，没有ID这个成员。</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就明白了。类模板和类模板的特化的作用，仅仅是指导编译器选择哪个编译，但是特化之间、特化和它原型的类模板之间，是分别独立实现的。所以如果多个特化、或者特化和对应的类模板有着类似的内容，很不好意思，你得写上若干遍了。</p><p>第三个问题，是写一个模板匹配任意类型的指针。对于 C 语言来说，因为没有泛型的概念，因此它提供了无类型的指针<code>void*</code>。它的优点是，所有指针都能转换成它。它的缺点是，一旦转换称它后，你就再也不知道这个指针到底是指向<code>float</code>或者是<code>int</code>或者是<code>struct</code>了。</p><p>比如说<code>copy</code>。</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>void copy(void* dst, void const* src, size_t elemSize, size_t elemCount, void (*copyElem)(void* dstElem, void const* srcElem))
{
    void const* reader = src;
    void const* writer = dst;
    for(size_t i = 0; i &lt; elemCount; ++i)
    {
        copyElem(writer, reader);
        advancePointer(reader, elemSize); // 把Reader指针往后移动一些字节
        advancePointer(writer, elemSize);
     }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么要提供 copyElem，是因为可能有些 struct 需要深拷贝，所以得用特殊的 copy 函数。这个在 C++98/03 里面就体现为拷贝构造和赋值函数。</p><p>但是不管怎么搞，因为这个函数的参数只是<code>void*</code>而已，当你使用了错误的 elemSize，或者传入了错误的 copyElem，就必须要到运行的时候才有可能看出来。注意，这还只是有可能而已。</p><p>那么 C++有了模板后，能否既能匹配任意类型的指针，同时又保留了类型信息呢？答案是显然的。至于怎么写，那就得充分发挥你的直觉了：</p><p>首先，我们需要一个<code>typename T</code>来指代“任意类型”这四个字：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们要写函数原型：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">?</span> dest<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">?</span> src<span class="token punctuation">,</span> size_t elemCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里的 <code>??</code> 要怎么写呢？既然我们有了模板类型参数 T，那我们不如就按照经验，写 <code>T*</code> 看看。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>T<span class="token operator">*</span> dst<span class="token punctuation">,</span> T <span class="token keyword">const</span><span class="token operator">*</span> src<span class="token punctuation">,</span> size_t elemCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译一下，咦，居然通过了。看来这里的语法与我们以前学到的知识并没有什么不同。这也是语言设计最重要的一点原则：一致性。它可以让你辛辛苦苦体验到的规律不至于白费。</p><p>最后就是实现：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>T<span class="token operator">*</span> dst<span class="token punctuation">,</span> T <span class="token keyword">const</span><span class="token operator">*</span> src<span class="token punctuation">,</span> size_t elemCount<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elemCount<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        dst<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是简洁了许多？你不需要再传入 size；只要你有正确的赋值函数，也不需要提供定制的 copy；也不用担心 dst 和 src 的类型不匹配了。</p><p>最后，我们把函数模板学到的东西，也应用到类模板里面：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">// 嗯，需要一个T</span>
<span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token comment">// 我要对所有的指针类型特化，所以这里就写T*</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>	<span class="token comment">// 用最高位表示它是一个指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后写个例子来测试一下，看看我们的 <code>T*</code> 能不能搞定 <code>float*</code>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">PrintID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ID of float*: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哈哈，大功告成。嗯，别急着高兴。待我问一个问题：你知道 <code>TypeToID&lt;float*&gt;</code> 后，这里的 T 是什么吗？换句话说，你知道下面这段代码打印的是什么吗？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ...</span>
<span class="token comment">// TypeToID 的其他代码，略过不表</span>
<span class="token comment">// ...</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">// 嗯，需要一个T</span>
<span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token comment">// 我要对所有的指针类型特化，所以这里就写T*</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> T		 SameAsT<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span> <span class="token comment">// 用最高位表示它是一个指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">PrintID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ID of float*: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>SameAsT <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>别急着运行，你先猜。</p><p>------------------------- 这里是给勤于思考的码猴的分割线 -------------------------------</p><p>OK，猜出来了吗，T 是<code>float</code>。为什么呢？因为你用 <code>float *</code> 匹配了 <code>T *</code>，所以 <code>T</code> 就对应 <code>float</code> 了。没想清楚的自己再多体会一下。</p><p>嗯，所以实际上，我们可以利用这个特性做一件事情：把指针类型的那个指针给“干掉”：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">RemovePointer</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> T Result<span class="token punctuation">;</span>  <span class="token comment">// 如果放进来的不是一个指针，那么它就是我们要的结果。</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">RemovePointer</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span>	<span class="token comment">// 祖传牛皮藓，专治各类指针</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> T Result<span class="token punctuation">;</span>  <span class="token comment">// 正如我们刚刚讲的，去掉一层指针，把 T* 这里的 T 取出来。</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    RemovePointer<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>Result x <span class="token operator">=</span> <span class="token number">5.0f</span><span class="token punctuation">;</span> <span class="token comment">// 喏，用RemovePointer后，那个Result就是把float*的指针处理掉以后的结果：float啦。</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然啦，这里我们实现的不算是真正的 <code>RemovePointer</code>，因为我们只去掉了一层指针。而如果传进来的是类似 <code>RemovePointer&lt;int**&gt;</code> 这样的东西呢？是的没错，去掉一层之后还是一个指针。<code>RemovePointer&lt;int**&gt;::Result</code> 应该是一个 <code>int*</code>，要怎么才能实现我们想要的呢？聪明的你一定能想到：只要像剥洋葱一样，一层一层一层地剥开，不就好了吗！相应地我们应该怎么实现呢？可以把 <code>RemovePointer</code> 的特化版本改成这样（当然如果有一些不明白的地方你可以暂时跳过，接着往下看，很快就会明白的）：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">RemovePointer</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 如果是传进来的是一个指针，我们就剥夺一层，直到指针形式不存在为止。</span>
    <span class="token comment">// 例如 RemovePointer&lt;int**&gt;，Result 是 RemovePointer&lt;int*&gt;::Result，</span>
    <span class="token comment">// 而 RemovePointer&lt;int*&gt;::Result 又是 int，最终就变成了我们想要的 int，其它也是类似。</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">RemovePointer</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>Result Result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是的没错，这便是我们想要的 <code>RemovePointer</code> 的样子。类似的你还可以试着实现 <code>RemoveConst</code>, <code>AddPointer</code> 之类的东西。</p><p>OK，回到我们之前的话题，如果这个时候，我需要给 <code>int*</code> 提供一个更加特殊的特化，那么我还得多提供一个：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ...</span>
<span class="token comment">// TypeToID 的其他代码，略过不表</span>
<span class="token comment">// ...</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">// 嗯，需要一个T</span>
<span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span>    <span class="token comment">// 我要对所有的指针类型特化，所以这里就写T*</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> T SameAsT<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span> <span class="token comment">// 用最高位表示它是一个指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token comment">// 嗯，int* 已经是个具体的不能再具体的类型了，所以模板不需要额外的类型参数了</span>
<span class="token keyword">class</span> <span class="token class-name">TypeToID</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token comment">// 嗯，对int*的特化。在这里呢，要把int*整体看作一个类型</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> ID <span class="token operator">=</span> <span class="token number">0x12345678</span><span class="token punctuation">;</span> <span class="token comment">// 给一个缺心眼的ID</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">PrintID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ID of int*: &quot;</span> <span class="token operator">&lt;&lt;</span> TypeToID<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ID <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，这个时候它会输出 0x12345678 的十进制（大概？）。 可能会有较真的人说，<code>int*</code> 去匹配 <code>T</code> 或者 <code>T*</code>，也是合法的。就和你说 22 岁以上能结婚，那 24 岁当然也能结婚一样。 那为什么 <code>int*</code> 就会找 <code>int*</code>，<code>float *</code>因为没有合适的特化就去找 <code>T*</code>，更一般的就去找 <code>T</code> 呢？废话，有专门为你准备的东西你不用，非要自己找事？这就是直觉。 但是呢，直觉对付更加复杂的问题还是没用的（也不是没用，主要是你没这个直觉了）。我们要把这个直觉，转换成合理的规则——即模板的匹配规则。 当然，这个匹配规则是对复杂问题用的，所以我们会到实在一眼看不出来的时候才会动用它。一开始我们只要把握：<strong>模板是从最特殊到最一般形式进行匹配的</strong> 就可以了。</p><h2 id="_3-3-即用即推导" tabindex="-1"><a class="header-anchor" href="#_3-3-即用即推导" aria-hidden="true">#</a> 3.3. 即用即推导</h2><h3 id="_3-3-1-视若无睹的语法错误" tabindex="-1"><a class="header-anchor" href="#_3-3-1-视若无睹的语法错误" aria-hidden="true">#</a> 3.3.1. 视若无睹的语法错误</h3><p>这一节我们将讲述模板一个非常重要的行为特点：那就是什么时候编译器会对模板进行推导，推导到什么程度。</p><p>这一知识，对于理解模板的编译期行为、以及修正模板编译错误都非常重要。</p><p>我们先来看一个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">Y</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ReboundType<span class="token punctuation">;</span>				        <span class="token comment">// 类型定义1</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>MemberType MemberType<span class="token punctuation">;</span>	<span class="token comment">// 类型定义2</span>
    <span class="token keyword">typedef</span> UnknownType MemberType3<span class="token punctuation">;</span>			    <span class="token comment">// 类型定义3</span>

    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> instance0<span class="token punctuation">;</span>
        <span class="token keyword">typename</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>MemberType instance1<span class="token punctuation">;</span>
        WTF instance2
        大王叫我来巡山 <span class="token operator">-</span> <span class="token operator">+</span> <span class="token operator">&amp;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把这段代码编译一下，类型定义 3 出错，其它的都没问题。不过到这里你应该会有几个问题：</p><ol><li>不是<code>struct X&lt;T&gt;</code>的定义是空的吗？为什么在<code>struct Y</code>内的类型定义 2 使用了 <code>X&lt;T&gt;::MemberType</code> 编译器没有报错？</li><li>类型定义 2 中的<code>typename</code>是什么鬼？为什么类型定义 1 就不需要？</li><li>为什么类型定义 3 会导致编译错误？</li><li>为什么<code>void foo()</code>在 MSVC 下什么错误都没报？</li></ol><p>这时我们就需要请出 C++11 标准 —— 中的某些概念了。这是我们到目前为止第一次参阅标准。我希望能尽量减少直接参阅标准的次数，因此即便是极为复杂的模板匹配决议我都暂时没有引入标准中的描述。 然而，Template 引入的“双阶段名称查找（Two phase name lookup）”堪称是 C++中最黑暗的角落 —— 这是 LLVM 的团队自己在博客上说的 —— 因此在这里，我们还是有必要去了解标准中是如何规定的。</p><h3 id="_3-3-2-名称查找-i-am-who-i-am" tabindex="-1"><a class="header-anchor" href="#_3-3-2-名称查找-i-am-who-i-am" aria-hidden="true">#</a> 3.3.2. 名称查找：I am who I am</h3><p>在 C++标准中对于“名称查找（name lookup）”这个高大上的名词的诠释，主要集中出现在三处。第一处是 3.4 节，标题名就叫“Name Lookup”；第二处在 10.2 节，继承关系中的名称查找；第三处在 14.6 节，名称解析（name resolution）。</p><p>名称查找/名称解析，是编译器的基石。对编译原理稍有了解的人，都知道“符号表”的存在及重要意义。考虑一段最基本的 C 代码：</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>int a = 0;
int b;
b = (a + 1) * 2;
printf(&quot;Result: %d&quot;, b);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，所有出现的符号可以分为以下几类：</p><ul><li><code>int</code>：类型标识符，代表整型；</li><li><code>a</code>, <code>b</code>, <code>printf</code>：变量名或函数名；</li><li><code>=</code>, <code>+</code>, <code>*</code>：运算符；</li><li><code>,</code>, <code>;</code>, <code>(</code>, <code>)</code>：分隔符；</li></ul><p>那么，编译器怎么知道<code>int</code>就是整数类型，<code>b=(a+1)*2</code>中的<code>a</code>和<code>b</code>就是整型变量呢？这就是名称查找/名称解析的作用：它告诉编译器，这个标识符（identifer）是在哪里被声明或定义的，它究竟是什么意思。</p><p>也正因为这个机制非常基础，所以它才会面临各种可能的情况，编译器也要想尽办法让它在大部分场合都表现的合理。比如我们常见的作用域规则，就是为了对付名称在不同代码块中传播、并且遇到重名要如何处理的问题。下面是一个最简单的、大家在语言入门过程中都会碰到的一个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    a <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Inside &lt;a&gt;: %d\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Outside &lt;a&gt;: %d\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* ------------ Console Output -----------------
Inside &lt;a&gt;: 2
Outside &lt;a&gt;: 0
--------------- Console Output -------------- */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我想大家尽管不能处理所有名称查找中所遇到的问题，但是对一些常见的名称查找规则也有了充分的经验，可以解决一些常见的问题。 但是模板的引入，使得名称查找这一本来就不简单的基本问题变得更加复杂了。 考虑下面这个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span>  <span class="token punctuation">{</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">AB</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">C</span>  <span class="token punctuation">{</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> v0<span class="token punctuation">,</span> C<span class="token operator">&amp;</span> v1<span class="token punctuation">)</span><span class="token punctuation">{</span>
    v0<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单分析上述代码很容易得到以下结论：</p><ol><li>函数<code>foo</code>中的变量<code>v1</code>已经确定是<code>struct C</code>的实例，所以，<code>v1.a = 2;</code>会导致编译错误，<code>v1.c = 3;</code>是正确的代码；</li><li>对于变量<code>v0</code>来说，这个问题就变得很微妙。如果<code>v0</code>是<code>struct A</code>或者<code>struct AB</code>的实例，那么<code>foo</code>中的语句<code>v0.a = 1;</code>就是正确的。如果是<code>struct C</code>，那么这段代码就是错误的。</li></ol><p>因此在模板定义的地方进行语义分析，并不能<strong>完全</strong>得出代码是正确或者错误的结论，只有到了实例化阶段，确定了模板参数的类型后，才知道这段代码正确与否。令人高兴的是，在这一问题上，我们和 C++标准委员会的见地一致，说明我们的 C++水平已经和 Herb Sutter 不分伯仲了。既然我们和 Herb Sutter 水平差不多，那凭什么人家就吃香喝辣？下面我们来选几条标准看看服不服：</p><blockquote><p><strong>14.6 名称解析（Name resolution）</strong></p></blockquote><blockquote><p><strong>1)</strong> 模板定义中能够出现以下三类名称：</p></blockquote><blockquote><ul><li>模板名称、或模板实现中所定义的名称；</li><li>和模板参数有关的名称；</li><li>模板定义所在的定义域内能看到的名称。</li></ul></blockquote><blockquote><p>…</p></blockquote><blockquote><p><strong>9)</strong> … 如果名字查找和模板参数有关，那么查找会延期到模板参数全都确定的时候。 …</p></blockquote><blockquote><p><strong>10)</strong> 如果（模板定义内出现的）名字和模板参数无关，那么在模板定义处，就应该找得到这个名字的声明。…</p></blockquote><blockquote><p><strong>14.6.2 依赖性名称（Dependent names）</strong></p></blockquote><blockquote><p><strong>1)</strong> …（模板定义中的）表达式和类型可能会依赖于模板参数，并且模板参数会影响到名称查找的作用域 … 如果表达式中有操作数依赖于模板参数，那么整个表达式都依赖于模板参数，名称查找延期到<strong>模板实例化时</strong>进行。并且定义时和实例化时的上下文都会参与名称查找。（依赖性）表达式可以分为类型依赖（类型指模板参数的类型）或值依赖。</p></blockquote><blockquote><p><strong>14.6.2.2 类型依赖的表达式</strong></p></blockquote><blockquote><p><strong>2)</strong> 如果成员函数所属的类型是和模板参数有关的，那么这个成员函数中的<code>this</code>就认为是类型依赖的。</p></blockquote><blockquote><p><strong>14.6.3 非依赖性名称（Non-dependent names）</strong></p></blockquote><blockquote><p><strong>1)</strong> 非依赖性名称在<strong>模板定义</strong>时使用通常的名称查找规则进行名称查找。</p></blockquote><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" target="_blank" rel="noopener noreferrer">Working Draft: Standard of Programming Language C++, N3337<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>知道差距在哪了吗：人家会说黑话。什么时候咱们也会说黑话了，就是标准委员会成员了，反正懂得也不比他们少。不过黑话确实不太好懂 —— 怪我翻译不好的人，自己看原文，再说好懂了人家还靠什么吃饭 —— 我们来举一个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    B b<span class="token punctuation">;</span>                  <span class="token comment">// B 是第三类名字，b 是第一类</span>
    T t<span class="token punctuation">;</span>                  <span class="token comment">// T 是第二类</span>
    X<span class="token operator">*</span> anthor<span class="token punctuation">;</span>            <span class="token comment">// X 这里代指 X&lt;T&gt;，第一类</span>
    <span class="token keyword">typedef</span> <span class="token keyword">int</span> Y<span class="token punctuation">;</span>        <span class="token comment">// int 是第三类</span>
    Y y<span class="token punctuation">;</span>                  <span class="token comment">// Y 是第一类</span>
    C c<span class="token punctuation">;</span>                  <span class="token comment">// C 什么都不是，编译错误。</span>
    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       b<span class="token punctuation">.</span>v <span class="token operator">+=</span> y<span class="token punctuation">;</span>          <span class="token comment">// b 是第一类，非依赖性名称</span>
       b<span class="token punctuation">.</span>v <span class="token operator">*=</span> T<span class="token double-colon punctuation">::</span>s_mem<span class="token punctuation">;</span>   <span class="token comment">// T::s_mem 是第二类</span>
                          <span class="token comment">// s_mem的作用域由T决定</span>
                          <span class="token comment">// 依赖性名称，类型依赖</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，按照标准的意思，名称查找会在模板定义和实例化时各做一次，分别处理非依赖性名称和依赖性名称的查找。这就是“两阶段名称查找”这一名词的由来。只不过这个术语我也不知道是谁发明的，它并没有出现的标准上，但是频繁出现在 StackOverflow 和 Blog 上。</p><p>接下来，我们就来解决 2.3.1 节中留下的几个问题。</p><p>先看第四个问题。为什么 MSVC 中，函数模板的定义内不管填什么编译器都不报错？因为 MSVC 在分析模板中成员函数定义时没有做任何事情。至于为啥连“大王叫我来巡山”都能过得去，这是 C++语法/语义分析的特殊性导致的。 C++是个非常复杂的语言，以至于它的编译器，不可能通过词法-语法-语义多趟分析清晰分割，因为它的语义将会直接干扰到语法：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    A<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段简短的代码中，就包含了两个歧义的可能，一是<code>A</code>是模板，于是<code>A&lt;T&gt;</code>是一个实例化的类型，<code>b</code>是变量，另外一种是比较表达式（Comparison Expression）的组合，<code>((A &lt; T) &gt; b)</code>。</p><p>甚至词法分析也会受到语义的干扰，C++11 中才明确被修正的<code>vector&lt;vector&lt;int&gt;&gt;</code>，就因为<code>&gt;&gt;</code>被误解为右移或流操作符，而导致某些编译器上的错误。因此，在语义没有确定之前，连语法都没有分析的价值。</p><p>大约是基于如此考量，为了偷懒，MSVC 将包括所有模板成员函数的语法/语义分析工作都挪到了第二个 Phase，于是乎连带着语法分析都送进了第二个阶段。符合标准么？显然不符合。</p><p>但是这里值得一提的是，MSVC 的做法和标准相比，虽然投机取巧，但并非有弊无利。我们来先说一说坏处。考虑以下例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ----------- X.h ------------</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实现代码</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// ---------- X.cpp -----------</span>

<span class="token comment">// ... 一些代码 ...</span>
X<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> xi<span class="token punctuation">;</span>
<span class="token comment">// ... 一些代码 ...</span>
X<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> xf<span class="token punctuation">;</span>
<span class="token comment">// ... 一些代码 ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时如果 X 中有一些与模板参数无关的错误，如果名称查找/语义分析在两个阶段完成，那么这些错误会很早、且唯一的被提示出来；但是如果一切都在实例化时处理，那么可能会导致不同的实例化过程提示同样的错误。而模板在运用过程中，往往会产生很多实例，此时便会大量报告同样的错误。</p><p>当然，MSVC 并不会真的这么做。根据推测，最终他们是合并了相同的错误。因为即便对于模板参数相关的编译错误，也只能看到最后一次实例化的错误信息：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">Y</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ReboundType<span class="token punctuation">;</span> <span class="token comment">// 类型定义1</span>
    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> instance0<span class="token punctuation">;</span>
        X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>MemberType instance1<span class="token punctuation">;</span>
        WTF instance2
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">poo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Y</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Y</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MSVC 下和模板相关的错误只有一个：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>error C2039: &#39;MemberType&#39;: is not a member of &#39;X&lt;T&gt;&#39;
          with
          [
              T=float
          ]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后是一些语法错误，比如<code>MemberType</code>不是一个合法的标识符之类的。这样甚至你会误以为<code>int</code>情况下模板的实例化是正确的。虽然在有了经验之后会发现这个问题挺荒唐的，但是仍然会让新手有困惑。</p><p>相比之下，更加遵守标准的 Clang 在错误提示上就要清晰许多：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>error: unknown type name &#39;WTF&#39;
    WTF instance2
    ^
error: expected &#39;;&#39; at end of declaration
    WTF instance2
                 ^
                 ;
error: no type named &#39;MemberType&#39; in &#39;X&lt;int&gt;&#39;
    typename X&lt;T&gt;::MemberType instance1;
    ~~~~~~~~~~~~~~~^~~~~~~~~~
    note: in instantiation of member function &#39;Y&lt;int&gt;::foo&#39; requested here
        Y&lt;int&gt;::foo();
                ^
error: no type named &#39;MemberType&#39; in &#39;X&lt;float&gt;&#39;
    typename X&lt;T&gt;::MemberType instance1;
    ~~~~~~~~~~~~~~~^~~~~~~~~~
    note: in instantiation of member function &#39;Y&lt;float&gt;::foo&#39; requested here
        Y&lt;float&gt;::foo();
                  ^
4 errors generated.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，Clang 的提示和标准更加契合。它很好地区分了模板在定义和实例化时分别产生的错误。</p><p>另一个缺点也与之类似。因为没有足够的检查，如果你写的模板没有被实例化，那么很可能缺陷会一直存在于代码之中。特别是模板代码多在头文件。虽然不如接口那么重要，但也是属于被公开的部分，别人很可能会踩到坑上。缺陷一旦传播开修复起来就没那么容易了。</p><p>但是正如我前面所述，这个违背了标准的特性，并不是一无是处。首先，它可以完美的兼容标准。符合标准的、能够被正确编译的代码，一定能够被 MSVC 的方案所兼容。其次，它带来了一个非常有趣的特性，看下面这个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> v<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">convertTo</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       a<span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// 这里需要A的实现</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    X<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x<span class="token punctuation">;</span>
    x<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子在 Clang 中是错误的，因为：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>error: variable has incomplete type &#39;A&#39;
                        A a;
                          ^
    note: forward declaration of &#39;A&#39;
     struct A;
            ^
1 error generated.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>符合标准的写法需要将类模板的定义，和函数模板的定义分离开：</p><blockquote><p>TODO 此处例子不够恰当，并且描述有歧义。需要在未来版本中修订。</p></blockquote><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> v<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">convertTo</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">convertTo</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   a<span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    X<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x<span class="token punctuation">;</span>
    x<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是其实我们知道，<code>foo</code>要到实例化之后，才需要真正的做语义分析。在 MSVC 上，因为函数实现就是到模板实例化时才处理的，所以这个例子是完全正常工作的。因此在上面这个例子中，MSVC 的实现要比标准更加易于写和维护，是不是有点写 Java/C 那种声明实现都在同一处的清爽感觉了呢！</p><p>扩展阅读： <a href="http://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html" target="_blank" rel="noopener noreferrer">The Dreaded Two-Phase Name Lookup<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_3-3-3-多余的-typename-关键字" tabindex="-1"><a class="header-anchor" href="#_3-3-3-多余的-typename-关键字" aria-hidden="true">#</a> 3.3.3. “多余的” typename 关键字</h3><p>到了这里，2.3.1 中提到的四个问题，还有三个没有解决：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">Y</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ReboundType<span class="token punctuation">;</span>						<span class="token comment">// 这里为什么是正确的？</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>MemberType MemberType2<span class="token punctuation">;</span>	<span class="token comment">// 这里的typename是做什么的？</span>
    <span class="token keyword">typedef</span> UnknownType MemberType3<span class="token punctuation">;</span>				<span class="token comment">// 这里为什么会出错？</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们运用我们 2.3.2 节中学习到的标准，来对 Y 内部做一下分析：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">Y</span>
<span class="token punctuation">{</span>
    <span class="token comment">// X可以查找到原型；</span>
    <span class="token comment">// X&lt;T&gt;是一个依赖性名称，模板定义阶段并不管X&lt;T&gt;是不是正确的。</span>
    <span class="token keyword">typedef</span> X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> ReboundType<span class="token punctuation">;</span>

    <span class="token comment">// X可以查找到原型；</span>
    <span class="token comment">// X&lt;T&gt;是一个依赖性名称，X&lt;T&gt;::MemberType也是一个依赖性名称；</span>
    <span class="token comment">// 所以模板声明时也不会管X模板里面有没有MemberType这回事。</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>MemberType MemberType2<span class="token punctuation">;</span>

    <span class="token comment">// UnknownType 不是一个依赖性名称</span>
    <span class="token comment">// 而且这个名字在当前作用域中不存在，所以直接报错。</span>
    <span class="token keyword">typedef</span> UnknownType MemberType3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面，唯一的问题就是第二个：<code>typename</code>是做什么的？</p><p>对于用户来说，这其实是一个语法噪音。也就是说，其实就算没有它，语法上也说得过去。事实上，某些情况下 MSVC 的确会在标准需要的时候，不用写<code>typename</code>。但是标准中还是规定了形如 <code>T::MemberType</code> 这样的<code>qualified id</code> 在默认情况下不是一个类型，而是解释为<code>T</code>的一个成员变量<code>MemberType</code>，只有当<code>typename</code>修饰之后才能作为类型出现。</p><p>事实上，标准对<code>typename</code>的使用规定极为复杂，也算是整个模板中的难点之一。如果想了解所有的标准，需要阅读标准 14.6 节下 2-7 条，以及 14.6.2.1 第一条中对于<code>current instantiation</code>的解释。</p><p>简单来说，如果编译器能在出现的时候知道它是一个类型，那么就不需要<code>typename</code>，如果必须要到实例化的时候才能知道它是不是合法，那么定义的时候就把这个名称作为变量而不是类型。</p><p>我们用一行代码来说明这个问题：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>a <span class="token operator">*</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在没有模板的情况下，这个语句有两种可能的意思：如果<code>a</code>是一个类型，这就是定义了一个指针<code>b</code>，它拥有类型<code>a*</code>；如果<code>a</code>是一个对象或引用，这就是计算一个表达式<code>a*b</code>，虽然结果并没有保存下来。可是如果上面的<code>a</code>是模板参数的成员，会发生什么呢？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    T<span class="token double-colon punctuation">::</span>a <span class="token operator">*</span> b<span class="token punctuation">;</span> <span class="token comment">// 这是指针定义还是表达式语句？</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器对模板进行语法检查的时候，必须要知道上面那一行到底是个什么——这当然可以推迟到实例化的时候进行（比如 VC，这也是上面说过 VC 可以不加<code>typename</code>的原因），不过那是另一个故事了——显然在模板定义的时候，编译器并不能妄断。因此，C++标准规定，在没有<code>typename</code>约束的情况下认为这里<code>T::a</code>不是类型，因此<code>T::a * b;</code> 会被当作表达式语句（例如乘法）；而为了告诉编译器这是一个指针的定义，我们必须在<code>T::a</code>之前加上<code>typename</code>关键字，告诉编译器<code>T::a</code>是一个类型，这样整个语句才能符合指针定义的语法。</p><p>在这里，我举几个例子帮助大家理解<code>typename</code>的用法，这几个例子已经足以涵盖日常使用<a href="https://goo.gl/zCRNYx" target="_blank" rel="noopener noreferrer">（预览）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> TA<span class="token punctuation">;</span> <span class="token comment">// 编译器当然知道 X&lt;T&gt; 是一个类型。</span>
    <span class="token keyword">typedef</span> X    TB<span class="token punctuation">;</span> <span class="token comment">// X 等价于 X&lt;T&gt; 的缩写</span>
    <span class="token keyword">typedef</span> T    TC<span class="token punctuation">;</span> <span class="token comment">// T 不是一个类型还玩毛</span>

    <span class="token comment">// ！！！注意我要变形了！！！</span>
    <span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token punctuation">{</span>
        <span class="token keyword">typedef</span> X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>     TD<span class="token punctuation">;</span>          <span class="token comment">// X 的内部，既然外部高枕无忧，内部更不用说了</span>
        <span class="token keyword">typedef</span> X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>Y  TE<span class="token punctuation">;</span>          <span class="token comment">// 嗯，这里也没问题，编译器知道Y就是当前的类型，</span>
                                      <span class="token comment">// 这里在VS2015上会有错，需要添加 typename，</span>
                                      <span class="token comment">// Clang 上顺利通过。</span>
        <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>Y TF<span class="token punctuation">;</span> <span class="token comment">// 这个居然要加 typename！</span>
                                      <span class="token comment">// 因为，X&lt;T*&gt;和X&lt;T&gt;不一样哦，</span>
                                      <span class="token comment">// 它可能会在实例化的时候被别的偏特化给抢过去实现了。</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">typedef</span> A TG<span class="token punctuation">;</span>                   <span class="token comment">// 嗯，没问题，A在外面声明啦</span>
    <span class="token keyword">typedef</span> B<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> TH<span class="token punctuation">;</span>                <span class="token comment">// B&lt;T&gt;也是一个类型</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">B</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type TI<span class="token punctuation">;</span> <span class="token comment">// 嗯，因为不知道B&lt;T&gt;::type的信息，</span>
                                    <span class="token comment">// 所以需要typename</span>
    <span class="token keyword">typedef</span> B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type TJ<span class="token punctuation">;</span>        <span class="token comment">// B&lt;int&gt; 不依赖模板参数，</span>
                                    <span class="token comment">// 所以编译器直接就实例化（instantiate）了</span>
                                    <span class="token comment">// 但是这个时候，B并没有被实现，所以就出错了</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-4-本章小结" tabindex="-1"><a class="header-anchor" href="#_3-4-本章小结" aria-hidden="true">#</a> 3.4. 本章小结</h2><p>这一章是写作中最艰难的一章，中间停滞了将近一年。因为要说清楚 C++模板中一些语法噪音和设计决议并不是一件轻松的事情。不过通过这一章的学习，我们知道了下面这几件事情：</p><ol><li><p><strong>部分特化/偏特化</strong> 和 <strong>特化</strong> 相当于是模板实例化过程中的<code>if-then-else</code>。这使得我们根据不同类型，选择不同实现的需求得以实现；</p></li><li><p>在 2.3.3 一节我们插入了 C++模板中最难理解的内容之一：名称查找。名称查找是语义分析的一个环节，模板内书写的 <strong>变量声明</strong>、<strong>typedef</strong>、<strong>类型名称</strong> 甚至 <strong>类模板中成员函数的实现</strong> 都要符合名称查找的规矩才不会出错；</p></li><li><p>C++编译器对语义的分析的原则是“大胆假设，小心求证”：在能求证的地方尽量求证 —— 比如两段式名称查找的第一阶段；无法检查的地方假设你是正确的 —— 比如<code>typedef typename A&lt;T&gt;::MemberType X;</code>在模板定义时因为<code>T</code>不明确不会轻易判定这个语句的死刑。</p></li></ol><p>从下一章开始，我们将进入元编程环节。我们将使用大量的示例，一方面帮助巩固大家学到的模板知识，一方面也会引导大家使用函数式思维去解决常见的问题。</p><h1 id="_4-深入理解特化与偏特化" tabindex="-1"><a class="header-anchor" href="#_4-深入理解特化与偏特化" aria-hidden="true">#</a> 4. 深入理解特化与偏特化</h1><h2 id="_4-1-正确的理解偏特化" tabindex="-1"><a class="header-anchor" href="#_4-1-正确的理解偏特化" aria-hidden="true">#</a> 4.1. 正确的理解偏特化</h2><h3 id="_4-1-1-偏特化与函数重载的比较" tabindex="-1"><a class="header-anchor" href="#_4-1-1-偏特化与函数重载的比较" aria-hidden="true">#</a> 4.1.1. 偏特化与函数重载的比较</h3><p>在前面的章节中，我们介绍了偏特化的形式、也介绍了简单的用例。因为偏特化和函数重载存在着形式上的相似性，因此初学者便会借用重载的概念，来理解偏特化的行为。只是，重载和偏特化尽管相似但仍有差异。</p><p>我们来先看一个函数重载的例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们展现了函数重载可以在两种条件下工作：参数数量相同、类型不同；参数数量不同。</p><p>仿照重载的形式，我们通过特化机制，试图实现一个模板的“重载”：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token punctuation">;</span>	 <span class="token comment">// (0) 这是原型</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">// (1) 这是 int 类型的&quot;重载&quot;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">// (2) 这是 float 类型的&quot;重载&quot;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// (3) 这是 int, int 类型的“重载”</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    DoWork<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>      i<span class="token punctuation">;</span>
    DoWork<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span>    f<span class="token punctuation">;</span>
    DoWork<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> ii<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子在字面上“看起来”并没有什么问题，可惜编译器在编译的时候仍然提示出错了<a href="http://goo.gl/zI42Zv" target="_blank" rel="noopener noreferrer"><code>goo.gl/zI42Zv</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>5 : error: too many template arguments for class template &#39;DoWork&#39;
template &lt;&gt; struct DoWork&lt;int, int&gt; {}; // 这是 int, int 类型的“重载”
^ ~~~~
1 : note: template is declared here
template &lt;typename T&gt; struct DoWork {}; // 这是原型
~~~~~~~~~~~~~~~~~~~~~ ^
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从编译出错的失望中冷静一下，在仔细看看函数特化/偏特化和一般模板的不同之处：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">X</span>      <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//                            ^^^^ 注意这里</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对，就是这个<code>&lt;T*&gt;</code>，跟在 X 后面的“小尾巴”，我们称作实参列表，决定了第二条语句是第一条语句的跟班。所以，第二条语句，即“偏特化”，必须要符合原型 X 的基本形式：那就是只有一个模板参数。这也是为什么<code>DoWork</code>尝试以<code>template &lt;&gt; struct DoWork&lt;int, int&gt;</code>的形式偏特化的时候，编译器会提示模板实参数量过多。</p><p>另外一方面，在类模板的实例化阶段，它并不会直接去寻找 <code>template &lt;&gt; struct DoWork&lt;int, int&gt;</code>这个小跟班，而是会先找到基本形式，<code>template &lt;typename T&gt; struct DoWork;</code>，然后再去寻找相应的特化。</p><p>我们以<code>DoWork&lt;int&gt; i;</code>为例，尝试复原一下编译器完成整个模板匹配过程的场景，帮助大家理解。看以下示例代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token punctuation">;</span>	      <span class="token comment">// (0) 这是原型</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment">// (1) 这是 int 类型的特化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>          <span class="token comment">// (2) 这是 float 类型的特化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span>U<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// (3) 这是指针类型的偏特化</span>

DoWork<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>    i<span class="token punctuation">;</span>  <span class="token comment">// (4)</span>
DoWork<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span> pf<span class="token punctuation">;</span> <span class="token comment">// (5)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，编译器分析(0), (1), (2)三句，得知(0)是模板的原型，(1)，(2)，(3)是模板(0)的特化或偏特化。我们假设有两个字典，第一个字典存储了模板原型，我们称之为<code>TemplateDict</code>。第二个字典<code>TemplateSpecDict</code>，存储了模板原型所对应的特化/偏特化形式。所以编译器在处理这几句时，可以视作</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 以下为伪代码</span>
TemplateDict<span class="token punctuation">[</span>DoWork<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    DoWork<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    DoWork<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    DoWork<span class="token operator">&lt;</span>U<span class="token operator">*</span><span class="token operator">&gt;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后 (4) 试图以<code>int</code>实例化类模板<code>DoWork</code>。它会在<code>TemplateDict</code>中，找到<code>DoWork</code>，它有一个形式参数<code>T</code>接受类型，正好和我们实例化的要求相符合。并且此时<code>T</code>被推导为<code>int</code>。(5) 中的<code>float*</code>也是同理。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">{</span>   <span class="token comment">// 以下为 DoWork&lt;int&gt; 查找对应匹配的伪代码</span>
    templateProtoInt <span class="token operator">=</span> TemplateDict<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>DoWork<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 查找模板原型，查找到(0)</span>
    <span class="token keyword">template</span> <span class="token operator">=</span> templatePrototype<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 以 int 对应 int 匹配到 (1)</span>
<span class="token punctuation">}</span>

<span class="token punctuation">{</span>   <span class="token comment">// 以下为DoWork&lt;float*&gt; 查找对应匹配的伪代码</span>
    templateProtoIntPtr <span class="token operator">=</span> TemplateDict<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>DoWork<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token comment">// 查找模板原型，查找到(0)</span>
    <span class="token keyword">template</span> <span class="token operator">=</span> templateProtoIntPtr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">)</span>            <span class="token comment">// 以 float* 对应 U* 匹配到 (3)，此时U为float</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么根据上面的步骤所展现的基本原理，我们随便来几个练习：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span>            <span class="token punctuation">;</span>    <span class="token comment">// 0</span>
                                                           <span class="token comment">// 原型有两个类型参数</span>
                                                           <span class="token comment">// 所以下面的这些偏特化的实参列表</span>
                                                           <span class="token comment">// 也需要两个类型参数对应</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>             <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>  T  <span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 1</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>             <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token punctuation">,</span> T  <span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 2</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>             <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>  T<span class="token operator">*</span> <span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 3</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>             <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>U<span class="token punctuation">,</span>  <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 4</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>             <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>U<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 5</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>U<span class="token operator">*</span><span class="token punctuation">,</span> T<span class="token operator">*</span> <span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 6</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>U<span class="token punctuation">,</span>  T<span class="token operator">*</span> <span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 7</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>             <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>

<span class="token comment">// 以下特化，分别对应哪个偏特化的实例？</span>
<span class="token comment">// 此时偏特化中的T或U分别是什么类型？</span>

X<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">,</span>  <span class="token keyword">int</span><span class="token operator">&gt;</span>      v0<span class="token punctuation">;</span>
X<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span>      v1<span class="token punctuation">;</span>
X<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span>  <span class="token keyword">double</span><span class="token operator">&gt;</span>   v2<span class="token punctuation">;</span>
X<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">,</span>  <span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">&gt;</span>  v3<span class="token punctuation">;</span>
X<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">,</span>  <span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span>   v4<span class="token punctuation">;</span>
X<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span>  <span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span>   v5<span class="token punctuation">;</span>
X<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>     <span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">&gt;</span>  v6<span class="token punctuation">;</span>
X<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span>    <span class="token keyword">int</span><span class="token operator">&gt;</span>      v7<span class="token punctuation">;</span>
X<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span>   v8<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面这段例子中，有几个值得注意之处。首先，偏特化时的模板形参，和原型的模板形参没有任何关系。和原型不同，它的顺序完全不影响模式匹配的顺序，它只是偏特化模式，如<code>&lt;U, int&gt;</code>中<code>U</code>的声明，真正的模式，是由<code>&lt;U, int&gt;</code>体现出来的。</p><p>这也是为什么在特化的时候，当所有类型都已经确定，我们就可以抛弃全部的模板参数，写出<code>template &lt;&gt; struct X&lt;int, float&gt;</code>这样的形式：因为所有列表中所有参数都确定了，就不需要额外的形式参数了。</p><p>其次，作为一个模式匹配，偏特化的实参列表中展现出来的“样子”，就是它能被匹配的原因。比如，<code>struct X&lt;T, T&gt;</code>中，要求模板的两个参数必须是相同的类型。而<code>struct X&lt;T, T*&gt;</code>，则代表第二个模板类型参数必须是第一个模板类型参数的指针，比如<code>X&lt;float***, float****&gt;</code>就能匹配上。当然，除了简单的指针、<code>const</code>和<code>volatile</code>修饰符，其他的类模板也可以作为偏特化时的“模式”出现，例如示例 8，它要求传入同一个类型的<code>unique_ptr</code>和<code>shared_ptr</code>。C++标准中指出下列模式都是可以被匹配的：</p><blockquote><p>N3337, 14.8.2.5/8</p></blockquote><blockquote><p>令<code>T</code>是模板类型实参或者类型列表（如 <em>int, float, double</em> 这样的，<code>TT</code>是 template-template 实参（参见 6.2 节），<code>i</code>是模板的非类型参数（整数、指针等），则以下形式的形参都会参与匹配：</p></blockquote><blockquote><p><code>T</code>, <code>cv-list T</code>, <code>T*</code>, <code>template-name &lt;T&gt;</code>, <code>T&amp;</code>, <code>T&amp;&amp;</code></p></blockquote><blockquote><p><code>T [ integer-constant ]</code></p></blockquote><blockquote><p><code>type (T)</code>, <code>T()</code>, <code>T(T)</code></p></blockquote><blockquote><p><code>T type ::*</code>, <code>type T::*</code>, <code>T T::*</code></p></blockquote><blockquote><p><code>T (type ::*)()</code>, <code>type (T::*)()</code>, <code>type (type ::*)(T)</code>, <code>type (T::*)(T)</code>, <code>T (type ::*)(T)</code>, <code>T (T::*)()</code>, <code>T (T::*)(T)</code></p></blockquote><blockquote><p><code>type [i]</code>, <code>template-name &lt;i&gt;</code>, <code>TT&lt;T&gt;</code>, <code>TT&lt;i&gt;</code>, <code>TT&lt;&gt;</code></p></blockquote><p>对于某些实例化，偏特化的选择并不是唯一的。比如 v4 的参数是<code>&lt;float*, float*&gt;</code>，能够匹配的就有三条规则，1，6 和 7。很显然，6 还是比 7 好一些，因为能多匹配一个指针。但是 1 和 6，就很难说清楚谁更好了。一个说明了两者类型相同；另外一个则说明了两者都是指针。所以在这里，编译器也没办法决定使用那个，只好报出了编译器错误。</p><p>其他的示例可以先自己推测一下， 再去编译器上尝试一番：<a href="http://goo.gl/9UVzje" target="_blank" rel="noopener noreferrer"><code>goo.gl/9UVzje</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><h3 id="_4-1-2-不定长的模板参数" tabindex="-1"><a class="header-anchor" href="#_4-1-2-不定长的模板参数" aria-hidden="true">#</a> 4.1.2. 不定长的模板参数</h3><p>不过这个时候也许你还不死心。有没有一种办法能够让例子<code>DoWork</code>像重载一样，支持对长度不一的参数列表分别偏特化/特化呢？</p><p>答案当然是肯定的。</p><p>首先，首先我们要让模板实例化时的模板参数统一到相同形式上。逆向思维一下，虽然两个类型参数我们很难缩成一个参数，但是我们可以通过添加额外的参数，把一个扩展成两个呀。比如这样：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>DoWork<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>   <span class="token keyword">void</span><span class="token operator">&gt;</span> i<span class="token punctuation">;</span>
DoWork<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">&gt;</span> f<span class="token punctuation">;</span>
DoWork<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>   <span class="token keyword">int</span> <span class="token operator">&gt;</span> ii<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时，我们就能写出统一的模板原型：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T0</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>继而偏特化/特化问题也解决了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>   <span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// (1) 这是 int 类型的特化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// (2) 这是 float 类型的特化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>    <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// (3) 这是 int, int 类型的特化</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显而易见这个解决方案并不那么完美。首先，不管是偏特化还是用户实例化模板的时候，都需要多撰写好几个<code>void</code>，而且最长的那个参数越长，需要写的就越多；其次，如果我们的<code>DoWork</code>在程序维护的过程中新加入了一个参数列表更长的实例，那么最悲惨的事情就会发生 —— 原型、每一个偏特化、每一个实例化都要追加上<code>void</code>以凑齐新出现的实例所需要的参数数量。</p><p>所幸模板参数也有一个和函数参数相同的特性：默认实参（Default Arguments）。只需要一个例子，你们就能看明白了<a href="http://goo.gl/TtmcY9" target="_blank" rel="noopener noreferrer"><code>goo.gl/TtmcY9</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T0</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>           <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>           <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>           <span class="token keyword">struct</span> <span class="token class-name">DoWork</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

DoWork<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> i<span class="token punctuation">;</span>
DoWork<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> f<span class="token punctuation">;</span>
DoWork<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
DoWork<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> ii<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有参数不足，即原型中参数<code>T1</code>没有指定的地方，都由 T1 自己的默认参数<code>void</code>补齐了。</p><p>但是这个方案仍然有些美中不足之处。</p><p>比如，尽管我们默认了所有无效的类型都以<code>void</code>结尾，所以正确的类型列表应该是类似于<code>&lt;int, float, char, void, void&gt;</code>这样的形态。但你阻止不了你的用户写出类似于<code>&lt;void, int, void, float, char, void, void&gt;</code>这样不符合约定的类型参数列表。</p><p>其次，假设这段代码中有一个函数，它的参数使用了和类模板相同的参数列表类型，如下面这段代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T0</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>T0 <span class="token keyword">const</span><span class="token operator">&amp;</span> p0<span class="token punctuation">,</span> T1 <span class="token keyword">const</span><span class="token operator">&amp;</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 0</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T0</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token operator">&lt;</span>T0<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>T0 <span class="token keyword">const</span><span class="token operator">&amp;</span> p0<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">X</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 调用函数 1</span>
    <span class="token class-name">X</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 调用函数 0</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，每加一个参数就要多写一个偏特化的形式，甚至还要重复编写一些可以共享的实现。</p><p>不过不管怎么说，以长参数加默认参数的方式支持变长参数是可行的做法，这也是 C++98/03 时代的唯一选择。</p><p>例如，<a href="https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/detail/tuple_basic.hpp" target="_blank" rel="noopener noreferrer"><code>Boost.Tuple</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>就使用了这个方法，支持了变长的 Tuple：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// Tuple 的声明，来自 boost</span>
<span class="token keyword">struct</span> <span class="token class-name">null_type</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span>
  <span class="token keyword">class</span> <span class="token class-name">T0</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T1</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span>
  <span class="token keyword">class</span> <span class="token class-name">T3</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T4</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T5</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span>
  <span class="token keyword">class</span> <span class="token class-name">T6</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T7</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T8</span> <span class="token operator">=</span> null_type<span class="token punctuation">,</span>
  <span class="token keyword">class</span> <span class="token class-name">T9</span> <span class="token operator">=</span> null_type<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">tuple</span><span class="token punctuation">;</span>

<span class="token comment">// Tuple的一些用例</span>
tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>
tuple<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>
tuple<span class="token operator">&lt;</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">B</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>C<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> C<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>
tuple<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>A<span class="token punctuation">,</span> B<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
tuple<span class="token operator">&lt;</span>A<span class="token operator">*</span><span class="token punctuation">,</span> tuple<span class="token operator">&lt;</span><span class="token keyword">const</span> A<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> B<span class="token operator">&amp;</span><span class="token punctuation">,</span> C<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> e<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，Boost.MPL 也使用了这个手法将<code>boost::mpl::vector</code>映射到<code>boost::mpl::vector _n_</code>上。但是我们也看到了，这个方案的缺陷很明显：代码臃肿和潜在的正确性问题。此外，过度使用模板偏特化、大量冗余的类型参数也给编译器带来了沉重的负担。</p><p>为了缓解这些问题，在 C++11 中，引入了变参模板（Variadic Template）。我们来看看支持了变参模板的 C++11 是如何实现 tuple 的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">tuple</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是一下子简洁了很多！这里的<code>typename... Ts</code>相当于一个声明，是说<code>Ts</code>不是一个类型，而是一个不定常的类型列表。同 C 语言的不定长参数一样，它通常只能放在参数列表的最后。看下面的例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>              <span class="token comment">// (1) error!</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>             <span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>              <span class="token comment">// (2)</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">&lt;</span>U<span class="token punctuation">,</span> Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// (3)</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">&lt;</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> U<span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// (4) error!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么第(1)条语句会出错呢？(1)是模板原型，模板实例化时，要以它为基础和实例化时的类型实参相匹配。因为 C++的模板是自左向右匹配的，所以不定长参数只能结尾。其他形式，无论写作<code>Ts, U</code>，或者是<code>Ts, V, Us,</code>，或者是<code>V, Ts, Us</code>都是不可取的。(4) 也存在同样的问题。</p><p>但是，为什么(3)中， 模板参数和(1)相同，都是<code>typename... Ts, typename U</code>，但是编译器却并没有报错呢？</p><p>答案在这一节的早些时候。(3)和(1)不同，它并不是模板的原型，它只是<code>Y</code>的一个偏特化。回顾我们在之前所提到的，偏特化时，模板参数列表并不代表匹配顺序，它们只是为偏特化的模式提供的声明，也就是说，它们的匹配顺序，只是按照<code>&lt;U, Ts...&gt;</code>来，而之前的参数只是告诉你<code>Ts</code>是一个类型列表，而<code>U</code>是一个类型，排名不分先后。</p><p>在这里，我们只提到了变长模板参数的声明，如何使用我们将在第四章讲述。</p><h3 id="_4-1-3-模板的默认实参" tabindex="-1"><a class="header-anchor" href="#_4-1-3-模板的默认实参" aria-hidden="true">#</a> 4.1.3. 模板的默认实参</h3><p>在上一节中，我们介绍了模板对默认实参的支持。当时我们的例子很简单，默认模板实参是一个确定的类型<code>void</code>或者自定义的<code>null_type</code>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span>
    <span class="token keyword">typename</span> <span class="token class-name">T0</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span> <span class="token operator">=</span> <span class="token keyword">void</span>
<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Tuple</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上，模板的默认参数不仅仅可以是一个确定的类型，它还能是以其他类型为参数的一个类型表达式。 考虑下面的例子：我们要执行两个同类型变量的除法，它对浮点、整数和其他类型分别采取不同的措施。 对于浮点，执行内置除法；对于整数，要处理除零保护，防止引发异常；对于其他类型，执行一个叫做<code>CustomeDiv</code>的函数。</p><p>第一步，我们先把浮点正确的写出来：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>include <span class="token operator">&lt;</span>type_traits<span class="token operator">&gt;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">CustomDiv</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Custom Div的实现</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> IsFloat <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>is_floating_point<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">CustomDiv</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>    <span class="token comment">// 偏特化A</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> lhs<span class="token operator">/</span>rhs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>   <span class="token comment">// 偏特化B</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> lhs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">2.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 调用偏特化A</span>
    <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 调用偏特化B</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实例化的时候，尽管我们只为<code>SafeDivide</code>指定了参数<code>T</code>，但是它的另一个参数<code>IsFloat</code>在缺省的情况下，可以根据<code>T</code>，求出表达式<code>std::is_floating_point&lt;T&gt;::value</code>的值作为实参的值，带入到<code>SafeDivide</code>的匹配中。</p><p>嗯，这个时候我们要再把整型和其他类型纳入进来，无外乎就是加这么一个参数<a href="http://goo.gl/0Lqywt" target="_blank" rel="noopener noreferrer"><code>goo.gl/0Lqywt</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>include <span class="token operator">&lt;</span>complex<span class="token operator">&gt;</span>
include <span class="token operator">&lt;</span>type_traits<span class="token operator">&gt;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">CustomDiv</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    T v<span class="token punctuation">;</span>
    <span class="token comment">// Custom Div的实现</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span>
    <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    <span class="token keyword">bool</span> IsFloat <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>is_floating_point<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>
    <span class="token keyword">bool</span> IsIntegral <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>is_integral<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value
<span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">CustomDiv</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>    <span class="token comment">// 偏特化A</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> lhs<span class="token operator">/</span>rhs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>   <span class="token comment">// 偏特化B</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> rhs <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> lhs<span class="token operator">/</span>rhs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">2.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	                          <span class="token comment">// 调用偏特化A</span>
    <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">// 调用偏特化B</span>
    <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>complex<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1.f</span><span class="token punctuation">,</span> <span class="token number">2.f</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1.f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.f</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用一般形式</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，这时也许你会注意到，<code>is_integral</code>，<code>is_floating_point</code>和其他类类型三者是互斥的，那能不能只使用一个条件量来进行分派呢？答案当然是可以的：<a href="http://goo.gl/jYp5J2" target="_blank" rel="noopener noreferrer"><code>goo.gl/jYp5J2</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>include <span class="token operator">&lt;</span>complex<span class="token operator">&gt;</span>
include <span class="token operator">&lt;</span>type_traits<span class="token operator">&gt;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">CustomDiv</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    T v<span class="token punctuation">;</span>
    <span class="token comment">// Custom Div的实现</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Enabled</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>true_type<span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">CustomDiv</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span>
    T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>is_floating_point<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&gt;</span><span class="token punctuation">{</span>    <span class="token comment">// 偏特化A</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> lhs<span class="token operator">/</span>rhs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span>
    T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>is_integral<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&gt;</span><span class="token punctuation">{</span>          <span class="token comment">// 偏特化B</span>
    <span class="token keyword">static</span> T <span class="token function">Do</span><span class="token punctuation">(</span>T lhs<span class="token punctuation">,</span> T rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> rhs <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> lhs<span class="token operator">/</span>rhs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">2.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 调用偏特化A</span>
    <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 调用偏特化B</span>
    <span class="token class-name">SafeDivide</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>complex<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1.f</span><span class="token punctuation">,</span> <span class="token number">2.f</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1.f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.f</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们借助这个例子，帮助大家理解一下这个结构是怎么工作的：</p><ol><li>对<code>SafeDivide&lt;int&gt;</code></li></ol><ul><li><p>通过匹配类模板的泛化形式，计算默认实参，可以知道我们要匹配的模板实参是<code>SafeDivide&lt;int, true_type&gt;</code></p></li><li><p>计算两个偏特化的形式的匹配：A 得到<code>&lt;int, false_type&gt;</code>,和 B 得到 <code>&lt;int, true_type&gt;</code></p></li><li><p>最后偏特化 B 的匹配结果和模板实参一致，使用它。</p></li></ul><ol start="2"><li>针对<code>SafeDivide&lt;complex&lt;float&gt;&gt;</code></li></ol><ul><li><p>通过匹配类模板的泛化形式，可以知道我们要匹配的模板实参是<code>SafeDivide&lt;complex&lt;float&gt;, true_type&gt;</code></p></li><li><p>计算两个偏特化形式的匹配：A 和 B 均得到<code>SafeDivide&lt;complex&lt;float&gt;, false_type&gt;</code></p></li><li><p>A 和 B 都与模板实参无法匹配，所以使用原型，调用<code>CustomDiv</code></p></li></ul><h2 id="_4-2-后悔药-sfinae" tabindex="-1"><a class="header-anchor" href="#_4-2-后悔药-sfinae" aria-hidden="true">#</a> 4.2. 后悔药：SFINAE</h2><p>考虑下面这个函数模板：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token double-colon punctuation">::</span>type u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到本节为止，我们所有的例子都保证了一旦咱们敲定了模板参数中 <code>T</code> 和 <code>U</code>，函数参变量 <code>t</code> 和 <code>u</code> 的类型都是成立的，比如下面这样：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">float</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token double-colon punctuation">::</span>type u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">callFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> X<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// T == int, typename U::type == X::type == float</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么这里有一个可能都不算是问题的问题 —— 对于下面的代码，你认为它会提示怎么样的错误：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">float</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Y</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">float</span> type2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token double-colon punctuation">::</span>type u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">callFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> X<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// T == int, typename U::type == X::type == float</span>
    <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Y<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ???</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候你也许会说：啊，这个简单，<code>Y</code> 没有 <code>type</code> 这个成员自然会出错啦！嗯，这个时候咱们来看看 Clang 给出的结果：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>error: no matching function for call to &#39;foo&#39;
   foo&lt;int, Y&gt;(5, 5.0); // ???
   ^~~~~~~~~~~
   note: candidate template ignored: substitution failure [with T = int, U = Y]: no type named &#39;type&#39; in &#39;Y&#39;
       void foo(T t, typename U::type u) {
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整翻译过来就是，直接的出错原因是没有匹配的 <code>foo</code> 函数，间接原因是尝试用 <code>[T = int, U = y]</code> 做类型替换的时候失败了，所以这个函数模板就被忽略了。等等，不是出错，而是被忽略了？那么也就是说，只要有别的能匹配的类型兜着，编译器就无视这里的失败了？</p><p>银河火箭队的阿喵说，就是这样。不信邪的朋友可以试试下面的代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">float</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Y</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">float</span> type2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token double-colon punctuation">::</span>type u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token double-colon punctuation">::</span>type2 u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">callFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> X<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// T == int, typename U::type == X::type == float</span>
    <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Y<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ???</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这下相信编译器真的是不关心替换失败了吧。我们管这种只要有正确的候选，就无视替换失败的做法为 SFINAE。</p><p>我们不用纠结这个词的发音，它来自于 Substitution failure is not an error 的首字母缩写。这一句之乎者也般难懂的话，由之乎者 —— 啊，不，Substitution，Failure 和 Error 三个词构成。</p><p>我们从最简单的词“Error”开始理解。Error 就是一般意义上的编译错误。一旦出现编译错误，大家都知道，编译器就会中止编译，并且停止接下来的代码生成和链接等后续活动。</p><p>其次，我们再说“Failure”。很多时候光看字面意思，很多人会把 Failure 和 Error 等同起来。但是实际上 Failure 很多场合下只是一个中性词。比如我们看下面这个虚构的例子就知道这两者的区别了。</p><p>假设我们有一个语法分析器，其中某一个规则需要匹配一个 token，它可以是标识符，字面量或者是字符串，那么我们会有下面的代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">switch</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword">case</span> IDENTIFIER<span class="token operator">:</span>
    <span class="token comment">// do something</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> LITERAL_NUMBER<span class="token operator">:</span>
    <span class="token comment">// do something</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> LITERAL_STRING<span class="token operator">:</span>
    <span class="token comment">// do something</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">default</span><span class="token operator">:</span>
    <span class="token keyword">throw</span> <span class="token function">WrongToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们当前的 token 是 <code>LITERAL_STRING</code> 的时候，那么第一步它在匹配 <code>IDENTIFIER</code> 时，我们可以认为它失败（failure）了，但是它在第三步就会匹配上，所以它并不是一个错误。</p><p>但是如果这个 token 既不是标识符、也不是数字字面量、也不是字符串字面量，而且我们的语法规定除了这三类值以外其他统统都是非法的时，我们才认为它是一个 error。</p><p>大家所熟知的函数重载也是如此。比如说下面这个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>A <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>B <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">callFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么 <code>foo( A() )</code> 虽然匹配 <code>foo(B const&amp;)</code> 会失败，但是它起码能匹配 <code>foo(A const&amp;)</code>，所以它是正确的；<code>foo( B() )</code> 能同时匹配两个函数原型，但是 <code>foo(B const&amp;)</code> 要更好一些，因此它选择了这个原型。而 <code>foo( C() );</code> 因为两个函数都匹配失败（Failure）了，所以它找不到相应的原型，这时才会报出一个编译器错误（Error）。</p><p>所以到这里我们就明白了，在很多情况下，Failure is not an error。编译器在遇到 Failure 的时候，往往还需要尝试其他的可能性。</p><p>好，现在我们把最后一个词，Substitution，加入到我们的字典中。现在这句话的意思就是说，我们要把 Failure is not an error 的概念，推广到 Substitution 阶段。</p><p>所谓 substitution，就是将函数模板中的形参，替换成实参的过程。概念很简洁但是实现却颇多细节，所以 C++标准中对这一概念的解释比较拗口。它分别指出了以下几点：</p><ul><li><p>什么时候函数模板会发生实参 替代（Substitute） 形参的行为；</p></li><li><p>什么样的行为被称作 Substitution；</p></li><li><p>什么样的行为不可以被称作 Substitution Failure —— 他们叫 SFINAE error。</p></li></ul><p>我们在此不再详述，有兴趣的同学可以参照<a href="http://en.cppreference.com/w/cpp/language/sfinae" target="_blank" rel="noopener noreferrer"><code>这里</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，这是标准的一个精炼版本。这里我们简单的解释一下。</p><p>考虑我们有这么个函数签名：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span>
    <span class="token keyword">typename</span> <span class="token class-name">T0</span><span class="token punctuation">,</span>
    <span class="token comment">// 一大坨其他模板参数</span>
    <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token comment">/* 和前面T有关的一大坨 */</span>
<span class="token operator">&gt;</span>
RType <span class="token comment">/* 和模板参数有关的一大坨 */</span>
<span class="token function">functionName</span> <span class="token punctuation">(</span>
    PType0 <span class="token comment">/* PType0 是和模板参数有关的一大坨 */</span><span class="token punctuation">,</span>
    PType1 <span class="token comment">/* PType1 是和模板参数有关的一大坨 */</span><span class="token punctuation">,</span>
    <span class="token comment">// ... 其他参数</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实现，和模板参数有关的一大坨</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，在这个函数模板被实例化的时候，所有函数签名上的“和模板参数有关的一大坨”被推导出具体类型的过程，就是替换。一个更具体的例子来解释上面的“一大坨”：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span>
    <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator <span class="token comment">// 1</span>
<span class="token operator">&gt;</span>
<span class="token keyword">typename</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type  <span class="token comment">// 1</span>
<span class="token function">foo</span><span class="token punctuation">(</span>
    T<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token comment">// 1</span>
    T<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token comment">// 1</span>
    <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>internal_type<span class="token punctuation">,</span> <span class="token comment">// 1</span>
    <span class="token keyword">typename</span> <span class="token class-name">add_reference</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">,</span> <span class="token comment">// 1</span>
    <span class="token keyword">int</span> <span class="token comment">// 这里都不需要 substitution</span>
<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// 根据定义，substitution只发生在函数签名上。</span>
  <span class="token comment">// 故而整个函数实现部分都不会存在 substitution。</span>
  <span class="token comment">// 这是一个重点需要记住。</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有标记为 <code>1</code> 的部分，都是需要替换的部分，而它们在替换过程中的失败（failure），就称之为替换失败（substitution failure）。</p><p>下面的代码是提供了一些替换成功和替换失败的示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">int</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Y</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">int</span> type2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Foo0</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>type2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Foo1</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// Foo2</span>

<span class="token keyword">void</span> <span class="token function">callFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span>X<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Foo0: Succeed, Foo1: Failed,  Foo2: Failed</span>
    <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span>Y<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Foo0: Failed,  Foo1: Succeed, Foo2: Failed</span>
    <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Foo0: Failed,  Foo1: Failed,  Foo2: Succeed</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，当我们指定 <code>foo&lt;Y&gt;</code> 的时候，substitution 就开始工作了，而且会同时工作在三个不同的 <code>foo</code> 签名上。如果我们仅仅因为 <code>Y</code> 没有 <code>type</code>，匹配 <code>Foo0</code> 失败了，就宣布代码有错，中止编译，那显然是武断的。因为 <code>Foo1</code> 是可以被正确替换的，我们也希望 <code>Foo1</code> 成为 <code>foo&lt;Y&gt;</code> 的原型。</p><p>std/boost 库中的 <code>enable_if</code> 是 SFINAE 最直接也是最主要的应用。所以我们通过下面 <code>enable_if</code> 的例子，来深入理解一下 SFINAE 在模板编程中的作用。</p><p>假设我们有两个不同类型的计数器（counter），一种是普通的整数类型，另外一种是一个复杂对象，它从接口 <code>ICounter</code> 继承，这个接口有一个成员叫做 increase 实现计数功能。现在，我们想把这两种类型的 counter 封装一个统一的调用：inc_counter。那么，我们直觉会简单粗暴的写出下面的代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">ICounter</span> <span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">ICounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Counter</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">ICounter</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
        <span class="token comment">// Implements</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> counterObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    counterObj<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> intTypeCounter<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token operator">++</span>intTypeCounter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Counter cntObj<span class="token punctuation">;</span>
    <span class="token keyword">uint32_t</span> cntUI32<span class="token punctuation">;</span>

    <span class="token comment">// blah blah blah</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span>cntObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span>cntUI32<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们非常希望它展现出预期的行为。因为其实我们是知道对于任何一个调用，两个 <code>inc_counter</code> 只有一个是能够编译正确的。“有且唯一”，我们理应当期望编译器能够挑出那个唯一来。</p><p>可惜编译器做不到这一点。首先，它就告诉我们，这两个签名</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> counterObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> intTypeCounter<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其实是一模一样的。我们遇到了 <code>redefinition</code>。</p><p>我们看看 <code>enable_if</code> 是怎么解决这个问题的。我们通过 <code>enable_if</code> 这个 <code>T</code> 对于不同的实例做个限定：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>
    T<span class="token operator">&amp;</span> counterObj<span class="token punctuation">,</span>
    <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>
        std<span class="token double-colon punctuation">::</span>is_base_of<span class="token operator">&lt;</span>ICounter<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value
    <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>
    T<span class="token operator">&amp;</span> counterInt<span class="token punctuation">,</span>
    <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>
        std<span class="token double-colon punctuation">::</span>is_integral<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value
    <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们解释一下，这个 <code>enable_if</code> 是怎么工作的，语法为什么这么丑：</p><p>首先，替换（substitution）只有在推断函数类型的时候，才会起作用。推断函数类型需要参数的类型，所以， <code>typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type</code> 这么一长串代码，就是为了让 <code>enable_if</code> 参与到函数类型中；</p><p>其次， <code>is_integral&lt;T&gt;::value</code> 返回一个布尔类型的编译器常数，告诉我们它是或者不是一个 <code>integral type</code>，<code>enable_if&lt;C&gt;</code> 的作用就是，如果这个 <code>C</code> 值为 <code>True</code>，那么 <code>enable_if&lt;C&gt;::type</code> 就会被推断成一个 <code>void</code> 或者是别的什么类型，让整个函数匹配后的类型变成 <code>void inc_counter&lt;int&gt;(int &amp; counterInt, void* dummy = nullptr);</code> 如果这个值为 <code>False</code> ，那么 <code>enable_if&lt;false&gt;</code> 这个特化形式中，压根就没有这个 <code>::type</code>，于是替换就失败了。和我们之前的例子中一样，这个函数原型就不会被产生出来。</p><p>所以我们能保证，无论对于 <code>int</code> 还是 <code>counter</code> 类型的实例，我们都只有一个函数原型通过了 substitution —— 这样就保证了它的“有且唯一”，编译器也不会因为你某个替换失败而无视成功的那个实例。</p><p>这个例子说到了这里，熟悉 C++的你，一定会站出来说我们只要把第一个签名改成：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>ICounter<span class="token operator">&amp;</span> counterObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就能完美解决这个问题了，根本不需要这么复杂的编译器机制。</p><p>嗯，你说的没错，在这里这个特性一点都没用。</p><p>这也提醒我们，当你觉得需要写 <code>enable_if</code> 的时候，首先要考虑到以下可能的替代方案：</p><ul><li><p>重载（适用于函数模板）</p></li><li><p>偏特化（适用于类模板）</p></li><li><p>虚函数</p></li></ul><p>但是问题到了这里并没有结束。因为 <code>increase</code> 毕竟是个虚函数。假如 <code>Counter</code> 需要调用的地方实在是太多了，这个时候我们会非常期望 <code>increase</code> 不再是个虚函数以提高性能。此时我们会调整继承层级：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">ICounter</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Counter</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">ICounter</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// impl</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么原有的 <code>void inc_counter(ICounter&amp; counterObj)</code> 就无法再执行下去了。这个时候你可能会考虑一些变通的办法：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>ICounter<span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>c<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Counter cntObj<span class="token punctuation">;</span>
    <span class="token keyword">uint32_t</span> cntUI32<span class="token punctuation">;</span>

    <span class="token comment">// blah blah blah</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span>cntObj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ICounter<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>cntObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span>cntUI32<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于调用 <code>1</code>，因为 <code>cntObj</code> 到 <code>ICounter</code> 是需要类型转换的，所以比 <code>void inc_counter(T&amp;) [T = Counter]</code> 要更差一些。然后它会直接实例化后者，结果实现变成了 <code>++cntObj</code>，BOOM！</p><p>那么我们做 <code>2</code> 试试看？嗯，工作的很好。但是等等，我们的初衷是什么来着？不就是让 <code>inc_counter</code> 对不同的计数器类型透明吗？这不是又一夜回到解放前了？</p><p>所以这个时候，就能看到 <code>enable_if</code> 是如何通过 SFINAE 发挥威力的了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>include <span class="token operator">&lt;</span>type_traits<span class="token operator">&gt;</span>
include <span class="token operator">&lt;</span>utility<span class="token operator">&gt;</span>
include <span class="token operator">&lt;</span>cstdint<span class="token operator">&gt;</span>

<span class="token keyword">struct</span> <span class="token class-name">ICounter</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Counter</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">ICounter</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// impl</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>
    T<span class="token operator">&amp;</span> counterObj<span class="token punctuation">,</span>
    <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>
        std<span class="token double-colon punctuation">::</span>is_base_of<span class="token operator">&lt;</span>ICounter<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value
    <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    counterObj<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>
    T<span class="token operator">&amp;</span> counterInt<span class="token punctuation">,</span>
    <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>
        std<span class="token double-colon punctuation">::</span>is_integral<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value
    <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token operator">++</span>counterInt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Counter cntObj<span class="token punctuation">;</span>
    <span class="token keyword">uint32_t</span> cntUI32<span class="token punctuation">;</span>

    <span class="token comment">// blah blah blah</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span>cntObj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span>cntUI32<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个代码是不是看起来有点脏脏的。眼尖的你定睛一瞧，咦， <code>ICounter</code> 不是已经空了吗，为什么我们还要用它作为基类呢？</p><p>这是个好问题。在本例中，我们用它来区分一个<code>counter</code>是不是继承自<code>ICounter</code>。最终目的，是希望知道 <code>counter</code> 有没有 <code>increase</code> 这个函数。</p><p>所以 <code>ICounter</code> 只是相当于一个标签。而于情于理这个标签都是个累赘。但是在 C++11 之前，我们并没有办法去写类似于：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样的函数签名，因为假如 <code>T</code> 是 <code>int</code>，那么 <code>c.increase()</code> 这个函数调用就不存在。但它又不属于 Type Failure，而是一个 Expression Failure，在 C++11 之前它会直接导致编译器出错，这并不是我们所期望的。所以我们才退而求其次，用一个类似于标签的形式来提供我们所需要的类型信息。以后的章节，后面我们会说到，这种和类型有关的信息我们可以称之为 <code>type traits</code>。</p><p>到了 C++11，它正式提供了 Expression SFINAE，这时我们就能抛开 <code>ICounter</code> 这个无用的 Tag，直接写出我们要写的东西：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Implements</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> intTypeCounter<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>decay_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">++</span>intTypeCounter<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">++</span>intTypeCounter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> counterObj<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>decay_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>counterObj<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    counterObj<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Counter cntObj<span class="token punctuation">;</span>
    <span class="token keyword">uint32_t</span> cntUI32<span class="token punctuation">;</span>

    <span class="token comment">// blah blah blah</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span>cntObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inc_counter</span><span class="token punctuation">(</span>cntUI32<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，还有一种情况只能使用 SFINAE，而无法使用包括继承、重载在内的任何方法，这就是 Universal Reference。比如，</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 这里的a是个通用引用，可以准确的处理左右值引用的问题。</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ArgT</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>ArgT<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们要限定 ArgT 只能是 float 的衍生类型，那么写成下面这个样子是不对的，它实际上只能接受 float 的右值引用。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时的唯一选择，就是使用 Universal Reference，并增加 <code>enable_if</code> 限定类型，如下面这样：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ArgT</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>
    ArgT<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">,</span>
    <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enabled_if<span class="token operator">&lt;</span>
        std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>decay_t<span class="token operator">&lt;</span>ArgT<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value
    <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面这些例子可以看到，SFINAE 最主要的作用，是保证编译器在泛型函数、偏特化、及一般重载函数中遴选函数原型的候选列表时不被打断。除此之外，它还有一个很重要的元编程作用就是实现部分的编译期自省和反射。</p><p>虽然它写起来并不直观，但是对于既没有编译器自省、也没有 Concept 的 C++11 来说，已经是最好的选择了。</p><h2 id="_4-3-concept-概念-对模板参数约束的直接描述" tabindex="-1"><a class="header-anchor" href="#_4-3-concept-概念-对模板参数约束的直接描述" aria-hidden="true">#</a> 4.3. Concept “概念”：对模板参数约束的直接描述</h2><h3 id="_4-3-1-概念-解决了什么问题" tabindex="-1"><a class="header-anchor" href="#_4-3-1-概念-解决了什么问题" aria-hidden="true">#</a> 4.3.1. “概念” 解决了什么问题</h3><p>从上一节可以看出，我们兜兜转转了那么久，就是为了解决两个问题：</p><ol><li><p>在模板进行特化的时候，盘算一下并告诉编译器这里能不能特化；</p></li><li><p>在函数决议面临多个候选的时候，如果有且仅有其中一个原型能够被函数决议接纳，那就决定是你了！</p></li></ol><p>如果语言能允许用户直接描述需求并传达给编译器，不就不用这么麻烦了么。其实在很多现代语言中，都有类似的语言要素存在，比如 C 的约束（constraint on type parameters)：</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>public class Employee {
  // ...
}

public class GenericList&lt;T&gt; where T : Employee {
  // ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例就非常清晰的呈现了我们对<code>GenericList</code>中<code>T</code>的要求是：它得是一个<code>Employee</code>或<code>Employee</code>的子类。</p><p>这种“清晰的”类型约束，在 C++中称作概念（Concept）。最早有迹可循的概念相关工作应当从 2003 年后就开始了。2006 年 Bjarne 在 POPL 06 上的一篇报告“Specifying C++ concepts”算是“近代”Concept 工作的首次公开亮相。委员会为 Concept 筹划数年，在 2008 年提出了第一版 Concepts 提案，试图进入 C++0x 的标准中。这也是 Concept 第一次在 C++社群当中被广泛“炒作”。不过 2009 年的会议，让“近代”Concept 在 N2617 草案戛然而止。</p><p>2013 年之后，Concept 改头换面为 Concept Lite 提案（N3701)卷土重来，历经多方博弈和多轮演化，最终形成了我们在 C++20 里看到的 Concept。有关于 Concept 的方法论和比较，B.S. 在白皮书中有过比较详细的交代。</p><p>总之，在 concept 进入标准之后，模板特化的类型约束写起来就方便与直接多了。而且这些约束之间还可以像表达式一样复用和组合。虽然因为 C++类型系统自身的琐碎导致基础库中的 concept 仍然相当的冗长，但是比起之前起码具备了可用性。</p><p>比如我们拿上一节中最后一个例子作为对比：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// SFINAE</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ArgT</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>
    ArgT<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">,</span>
    <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enabled_if<span class="token operator">&lt;</span>
        std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>decay_t<span class="token operator">&lt;</span>ArgT<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value
    <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Concept</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ArgT</span><span class="token operator">&gt;</span>
  <span class="token keyword">requires</span> std<span class="token double-colon punctuation">::</span>same_as<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>remove_cvref<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>ArgT<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，concept 之后的表达式消除了语法噪音，显得更为简洁一些。而对于之前++的例子，concept 下则更为扼要：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">concept</span> <span class="token class-name">Incrementable</span> <span class="token operator">=</span> <span class="token keyword">requires</span> <span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span>Incrementable T<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> intTypeCounter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">++</span>intTypeCounter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接告诉编译器，我们对 T 的要求是你得有<code>++</code>。</p><p>当然有人会问，那能不能直接写成以下形式，不是更简单吗？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">requires</span> <span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>答案是：不能。 因为<code>requires</code>作为关键字/保留字是存在二义性的。当它用于函数模板或者类模板的声明时，它是一个 constraint，后面需要跟着 concept 表达式；而用于 concept 中，则是一个 required expression，用于 concept 的求解。既然 constraint 后面跟着一个 concept 表达式，而 requires 也可以用来定义一个 concept expression，那么一个风骚的想法形成了：我能不能用 <code>requires (requires (T t) {++t;})</code> 来约束模板参数呢？</p><p>当然是可以的！C++就是这么的简（<s>有</s>）单（<s>病</s>）！</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">requires</span> <span class="token punctuation">(</span><span class="token keyword">requires</span> <span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>t<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">inc_counter</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>总而言之，除了这些烦人的问题，“概念”的出现，使得模板的出错提示也清爽了些许 —— 虽然大佬们都在鼓吹 concept 让模板出错多么好调试，但是实际上模板出错，有一半是来源自类型系统本质上的复杂性，概念并不能解决这一问题。</p><p>比如这里使用 SFINAE 的提示：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>&lt;source&gt;:23:5: error: no matching function for call to &#39;Inc&#39;
    Inc(y);
    ^~~
&lt;source&gt;:5:6: note: candidate template ignored: substitution failure [with T = X]: cannot increment value of type &#39;X&#39;
void Inc(T&amp; v, std::decay_t&lt;decltype(++v)&gt;* = nullptr)
     ^                               ~~
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而这里是使用了 concept 的提示。</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>&lt;source&gt;:25:5: error: no matching function for call to &#39;Inc_Concept&#39;
    Inc_Concept(y);
    ^~~~~~~~~~~
&lt;source&gt;:13:6: note: candidate template ignored: constraints not satisfied [with T = X]
void Inc_Concept(T&amp; v)
     ^
&lt;source&gt;:12:11: note: because &#39;X&#39; does not satisfy &#39;Incrementable&#39;
template &lt;Incrementable T&gt;
          ^
&lt;source&gt;:10:41: note: because &#39;++t&#39; would be invalid: cannot increment value of type &#39;X&#39;
concept Incrementable = requires(T t) { ++t; };
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然在这个例子中，通过 <em>Concept</em> 获得出错提示看起来要比使用 <em>SFINAE</em> 所获得的错误描述要更长一点，但是对于更加复杂类型来说，则会友善许多。以后会找个例子给大家陈述。</p><h3 id="_4-3-2-概念-入门" tabindex="-1"><a class="header-anchor" href="#_4-3-2-概念-入门" aria-hidden="true">#</a> 4.3.2. &quot;概念&quot;入门</h3><h1 id="_5-未完成章节" tabindex="-1"><a class="header-anchor" href="#_5-未完成章节" aria-hidden="true">#</a> 5. 未完成章节</h1><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code># 6. 元编程下的数据结构与算法
## 6.1. 表达式与数值计算
## 6.2. 获得类型的属性——类型萃取（Type Traits）
## 6.3. 列表与数组
## 6.4. 字典结构
## 6.5. “快速”排序
## 6.6. 其它常用的“轮子”

# 7. 非模板的编译期计算

# 8. 模板的进阶技巧
## 8.1. 嵌入类
## 8.2. Template-Template Class
## 8.3. 高阶函数
## 8.4. 闭包：模板的“基于对象”
stl allocator?
mpl::apply
## 8.5. 占位符(placeholder)：在C++中实现方言的基石
## 8.6. 编译期“多态”

#   9. 模板的威力：从foreach, transform到Linq
## 9.1. Foreach与Transform
## 9.2. Boost中的模板
Any Spirit Hana TypeErasure
## 9.3. Reactor、Linq与C++中的实践
## 9.4. 更高更快更强：从Linq到FP

#   10. 结语：讨论有益，争端无用
## 10.1. 更好的编译器，更友善的出错信息
## 10.2. 模板的症结：易于实现，难于完美
## 10.3. 一些期望
alexandrescu 关于 min max 的讨论：《再谈Min和Max》
std::experimental::any / boost.any 对于 reference 的处理
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/Organic-Fish/Notes/edit/main/./docs/Language/wuye9036_CppTemplateTutorial.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><!----><!----></footer><!----><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><!----></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-42b6f949.js" defer></script>
  </body>
</html>
