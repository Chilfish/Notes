import{_ as r,V as s,W as h,$ as e,X as d,Y as t,Z as n,a1 as o,a0 as l,F as a}from"./framework-dc28d300.js";const u={},p=e("p",null,[e("br"),e("p",{style:{"font-size":"32px","font-weight":"bold"}},"目录")],-1),m=l('<ul><li><a href="#dom-%E6%A0%91">DOM 树</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#dom-%E7%9A%84%E8%87%AA%E5%8A%A8%E4%BF%AE%E6%AD%A3">DOM 的自动修正</a></li><li><a href="#%E8%AE%BF%E9%97%AE-dom">访问 DOM</a></li><li><a href="#%E4%B8%BB%E8%A6%81%E7%9A%84-dom-%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7">主要的 DOM 节点属性</a></li><li><a href="#nodelist-%E4%B8%8E-htmlcollection">NodeList 与 HTMLCollection</a></li></ul></li><li><a href="#dom-%E5%AF%B9%E8%B1%A1">DOM 对象</a><ul><li><a href="#document">Document</a><ul><li><a href="#%E6%96%B9%E6%B3%95">方法</a><ul><li><a href="#%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2%E5%9E%8B">节点查询型</a></li><li><a href="#%E9%A1%B5%E9%9D%A2%E4%BF%AE%E6%94%B9%E5%9E%8B">页面修改型</a></li><li><a href="#%E8%8A%82%E7%82%B9%E5%88%9B%E9%80%A0%E5%9E%8B">节点创造型</a></li></ul></li><li><a href="#%E5%B1%9E%E6%80%A7">属性</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li><li><a href="#element">Element</a><ul><li><a href="#%E6%96%B9%E6%B3%95-1">方法</a></li><li><a href="#%E5%B1%9E%E6%80%A7-1">属性</a></li></ul></li><li><a href="#dom-%E4%BA%8B%E4%BB%B6">DOM 事件</a></li><li><a href="#image-%E5%AF%B9%E8%B1%A1">Image 对象</a></li></ul></li></ul>',1),g=l('<h2 id="dom-树" tabindex="-1"><a class="header-anchor" href="#dom-树" aria-hidden="true">#</a> DOM 树</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>HTML 文档的主干是标签（tag）。根据文档对象模型（DOM），每个 HTML 标签都是一个对象。嵌套的标签是闭合标签的“子标签（children）”。标签内的文本也是一个对象 所有这些对象都可以通过 JS 来访问，我们可以使用它们来修改页面。例如，<code>document.body</code> 是表示 <code>&lt;body&gt;</code> 标签的对象</p><ul><li><p><strong>节点：</strong></p><ul><li>每个树的节点都是一个对象。 <br>    标签被称为 元素节点（或者仅仅是元素），并形成了树状结构：<code>&lt;html&gt;</code> 在根节点，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 是其子项，等。 <br>    元素内的文本形成 文本节点，被标记为 <code>＃text</code>。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子</li></ul></li><li><p>请注意文本节点中的<strong>特殊字符：</strong></p><ul><li>换行符：<code>↵</code>（在 JS 中为 <code>\\n</code>）</li><li>空格：<code>␣</code></li></ul></li></ul><p>空格和换行符都是完全有效的字符，就像字母和数字。它们形成<strong>文本节点</strong>并成为 DOM 的一部分</p><h3 id="dom-的自动修正" tabindex="-1"><a class="header-anchor" href="#dom-的自动修正" aria-hidden="true">#</a> DOM 的自动修正</h3><p>如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它 例如，顶级标签总是 <code>&lt;html&gt;</code>。即使它不存在于文档中 — 它也会出现在 DOM 中，因为浏览器会创建它。对于 <code>&lt;body&gt;</code> 也是一样 例如，如果一个 HTML 文件中只有一个单词 “Hello”，浏览器则会把它包装到 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 中，并且会添加所需的 <code>&lt;head&gt;</code></p><h3 id="访问-dom" tabindex="-1"><a class="header-anchor" href="#访问-dom" aria-hidden="true">#</a> 访问 DOM</h3><p>给定一个 DOM 节点，我们可以使用导航（navigation）属性访问其直接的邻居，并返回实时更新的 <strong>集合 (Set)</strong></p><ul><li>这些属性主要分为两组： <ul><li>对于所有节点： <br>    <code>parentNode</code>，<code>childNodes</code>，<code>firstChild</code>，<code>lastChild</code>，<code>previousSibling</code>，<code>nextSibling</code></li><li>仅对于元素节点： <br>    <code>parentElement</code>，<code>children</code>，<code>firstElementChild</code>，<code>lastElementChild</code>，<code>previousElementSibling</code>，<code>nextElementSibling</code></li></ul></li></ul><p>某些类型的 DOM 元素，例如 table，提供了用于访问其内容的其他属性和集合</p><p>且由于空格与换行也算作节点，因此用 <code>*Nodes</code> 访问是包括了这些<strong>文本节点</strong>的</p><h3 id="主要的-dom-节点属性" tabindex="-1"><a class="header-anchor" href="#主要的-dom-节点属性" aria-hidden="true">#</a> 主要的 DOM 节点属性</h3><ul><li><code>nodeType</code> <br>    我们可以使用它来查看节点是文本节点还是元素节点。它具有一个数值型值：1 表示元素，3 表示文本节点，其他一些则代表其他节点类型。只读</li><li><code>nodeName/tagName</code> <br>    用于元素名，标签名（除了 XML 模式，都要大写）。对于非元素节点，nodeName 描述了它是什么。只读</li><li><code>innerHTML</code> <br>    元素的 HTML 内容。可以被修改</li><li><code>outerHTML</code> <br>    元素的完整 HTML。对 <code>elem.outerHTML</code> 的写入操作不会触及 elem 本身。而是在外部上下文中将其替换为新的 HTML</li><li><code>nodeValue/data</code> <br>    非元素节点（文本、注释）的内容。两者几乎一样，我们通常使用 data。可以被修改</li><li><code>textContent</code> <br>    元素内的文本：HTML 减去所有 <code>&lt;tags&gt;</code>。写入文本会将文本放入元素内，所有特殊字符和标签均被视为文本。可以安全地插入用户生成的文本，并防止不必要的 HTML 插入</li><li><code>hidden</code> <br>    当被设置为 true 时，执行与 CSS <code>display:none</code> 相同的事</li></ul><p>DOM 节点还具有其他属性，具体有哪些属性则取决于它们的类。例如，<code>&lt;input&gt;</code> 元素 支持 value，type，而 <code>&lt;a&gt;</code> 元素 则支持 href 等。大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性</p><h3 id="nodelist-与-htmlcollection" tabindex="-1"><a class="header-anchor" href="#nodelist-与-htmlcollection" aria-hidden="true">#</a> NodeList 与 HTMLCollection</h3><p><code>HTMLCollection</code> 是一个实时更新的节点对象，由 <code>getElementsByClassName()</code> | <code>node.children</code> 获得</p><p><code>NodeList</code> 是一个 DOM 节点快照的集合，仅检测 <code>innerHTML</code> 的更新，由 <code>querySelectorAll()</code> | <code>node.childNodes</code> 获得</p><ul><li>但只有 <code>NodeList</code> 才能被 <code>forEach()</code> 和 <code>for(.. of ..)</code> 遍历。但可以转为数组：<code>const arr = [...HTMLCol]</code></li></ul><h2 id="dom-对象" tabindex="-1"><a class="header-anchor" href="#dom-对象" aria-hidden="true">#</a> DOM 对象</h2><h3 id="document" tabindex="-1"><a class="header-anchor" href="#document" aria-hidden="true">#</a> Document</h3><p>以 <code>document.*</code> 为形式的对象和方法</p><h4 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h4><h5 id="节点查询型" tabindex="-1"><a class="header-anchor" href="#节点查询型" aria-hidden="true">#</a> 节点查询型</h5><ul><li><p><code>document.getElementById()</code>：根据元素 id 返回元素，返回值是 Element 类型，如果不存在该元素，则返回 null.</p></li><li><p><code>document.getElementsBy\\*()</code>：</p><ul><li><code>document.getElementsByClassName()</code>： 根据元素的 class 返回一个即时的 <code>HTMLCollection</code></li><li><code>document.getElementsByName()</code> 通过 name 属性来获取元素，返回一个即时的 <code>NodeList</code> 对象</li></ul><blockquote><p>但这些 <code>getElementsBy*</code> 已经成了历史的眼泪......因为还不如用 <strong>选择器</strong> 查找。但同时，也就这些是实时更新的</p></blockquote></li><li><p><code>document.querySelector()</code> 通过 css 选择器来查找，使用 <strong>深度优先搜索</strong> 返回第一个匹配的元素，如果没有匹配的元素，则返回 null。且相当于是 <code>document.querySelectorAll()[0]</code> 但速度更快 <strong>即</strong>：若有相同的选择器，优先返回嵌套最深的那一个 <strong>但是</strong>：<code>querySelector</code> 是 <strong>静态</strong> 的，不随文档而变化，且没有 <code>length</code></p></li></ul><h5 id="页面修改型" tabindex="-1"><a class="header-anchor" href="#页面修改型" aria-hidden="true">#</a> 页面修改型</h5><ul><li><p><strong>插入节点</strong> 元素插入方法，指明了不同的插入位置：</p><ul><li><code>node.append(...nodes or strings)</code> —— 在 node 末尾 插入节点或字符串，</li><li><code>node.prepend(...nodes or strings)</code> —— 在 node 开头 插入节点或字符串，</li><li><code>node.before(...nodes or strings)</code> —— 在 node 前面 插入节点或字符串，</li><li><code>node.after(...nodes or strings)</code> —— 在 node 后面 插入节点或字符串，</li><li><code>node.replaceWith(...nodes or strings)</code> —— 将 node 替换为给定的节点或字符串</li></ul><p><strong>注意</strong>：</p><ol><li>如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点。也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方</li><li>如果 child 绑定了事件，被移动时，它依然绑定着该事件</li></ol></li><li><p><strong>替换</strong>：<code>node.replaceWith(...nodes or strings)</code> — 替换 node</p></li><li><p>子节点修改 <strong>*Old School</strong></p><ul><li><code>parent.appendChild(child);</code> 将指定的节点添加到调用该方法的节点的子元素的末尾 child 节点将会作为 parent 节点的最后一个子节点</li><li><code> parentNode.insertBefore(newNode, refNode)</code> 用来添加一个节点到一个参照节点之前 <ul><li><code>parentNode</code> 表示新节点被添加后的父节点</li><li><code>newNode</code> 表示要添加的节点</li><li><code>refNode</code> 表示参照节点，新节点会添加到这个节点之前</li></ul></li><li><code>parent.removeChild(node)</code> 删除指定的子节点并返回</li><li><code>deletedChild</code> 指向被删除节点的引用，它等于 node，被删除的节点仍然存在于内存中，可以对其进行下一步操作</li><li><code>parent.replaceChild(newChild, oldChild)</code> 用于使用一个节点替换另一个节点 <ul><li><code>newChild</code> 是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置</li><li><code>oldChild</code> 是被替换的节点</li></ul></li></ul></li></ul><blockquote><p>由于历史原因，还存在“老式”的 DOM 操作方法。这些方法来自真正的远古时代。如今，没有理由再使用它们了</p></blockquote><h5 id="节点创造型" tabindex="-1"><a class="header-anchor" href="#节点创造型" aria-hidden="true">#</a> 节点创造型</h5><ul><li><p><code>document.createElement(tagName)</code>：通过传入指定的一个<strong>标签名</strong>来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签</p></li><li><p><code>document.createTextNode(value)</code>：用来创建一个文本节点，接收一个参数，这个参数就是文本节点中的</p></li><li><p><code>let newNode = oldNode.cloneNode(deep)</code>：返回调用该方法的节点的一个副本</p><ul><li><code>node</code> 将要被克隆的节点</li><li><code>dupNode</code> 克隆生成的副本节点</li><li><code>deep</code>（可选）是否采用深度克隆,如果为 true,则该节点的所有后代节点也都会被克隆,如果为 false,则只克隆该节点本身.</li></ul><p><strong>注意</strong>:</p><ol><li>和 <code>createElement</code> 一样，<code>cloneNode</code> 创建的节点只是游离有 HTML 文档外的节点，要调用 <code>appendChild</code> 方法才能添加到文档树中</li><li>如果复制的元素有 id，则其副本同样会包含该 id，由于 <strong>id 具有唯一性</strong>，所以在复制节点后必须要修改其 id</li><li>调用接收的 deep 参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同</li><li>如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论： <ol><li>如果是通过 <code>addEventListener</code> 或者比如 <code>onclick</code> 进行绑定事件，则副本节点不会绑定该事件</li><li>如果是内联方式绑定比如：<code>&lt;div onclick=&quot;showParent()&quot;&gt;&lt;/div&gt;</code>，这样的话，副本节点同样会触发事件</li></ol></li></ol></li></ul><h4 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h4><ul><li><code>document.cookie</code>：返回与当前文档有关的所有 cookie</li><li><code>document.URL</code>：返回当前文档在服务器的绝对路径</li><li><code>document.domain</code>：返回当前文档的域名</li><li><code>document.forms</code>、<code>document.images</code>、<code>document.links</code>、<code>document.scripts</code>、<code>document.title</code>：返回这些的集合</li><li><code>document.referrer</code>：返回跳转到当前文档的链接</li></ul><h4 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h4>',33),E={href:"https://juejin.cn/post/6844903604445249543#heading-2",target:"_blank",rel:"noopener noreferrer"},f={href:"https://zh.javascript.info/searching-elements-dom",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.zhihu.com/question/404365645/answer/1314691976",target:"_blank",rel:"noopener noreferrer"},M=l('<h3 id="element" tabindex="-1"><a class="header-anchor" href="#element" aria-hidden="true">#</a> Element</h3><p>元素一定是节点，但节点不一定是元素 =&gt; 节点还分文本节点、注释节点等等</p><h4 id="方法-1" tabindex="-1"><a class="header-anchor" href="#方法-1" aria-hidden="true">#</a> 方法</h4><h4 id="属性-1" tabindex="-1"><a class="header-anchor" href="#属性-1" aria-hidden="true">#</a> 属性</h4><ul><li><code>ele.attributes</code>：返回包含元素属性(id, class, data, name ...)的属性数组，可直接用 <code>attr.id</code>访问</li><li><code>ele.childNodes</code>：返回元素的子节点数组(NodeList)</li><li><code>ele.children</code>：返回元素的子元素的集合(HTMLCollection)</li><li><code>ele.parentElement</code>：返回元素的父元素</li><li><code>ele.classList</code>：返回元素的类名数组</li><li><code>ele.className</code>：返回元素的类名(string)</li><li><code>ele.firstChild</code> | <code>ele.firstElementChild</code>：返回元素的第一个子节点 | 元素</li><li><code>ele.nodeName</code>：返回元素的大写标签名</li><li><code>ele.nextElementSibling</code> | <code>ele.previousElementSibling</code>：返回元素的兄弟元素</li><li><code>ele.title</code>：设置或返回元素的 title 属性</li></ul><h3 id="dom-事件" tabindex="-1"><a class="header-anchor" href="#dom-事件" aria-hidden="true">#</a> DOM 事件</h3>',6),B=l(`<h3 id="image-对象" tabindex="-1"><a class="header-anchor" href="#image-对象" aria-hidden="true">#</a> Image 对象</h3><ul><li><strong>创建：</strong><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 可带两个参数表宽高</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>属性：</strong><ul><li><code>src</code>：返回图像的 src</li><li><code>currentSrc</code>：返回图像的绝对路径</li><li><code>alt</code>：返回图像的 alt</li><li><code>width</code>、<code>height</code>：返回图片的显示宽高</li><li><code>naturalWidth</code>：返回图片的实际宽高</li><li><code>complete</code>：返回图片加载完成情况的布尔值</li><li><code>crossOrigin</code>：返回图片的跨域设置，有两种情况： <ul><li><code>anonymous</code>：跨域请求不要求用户身份（<code>credentials</code>），这是默认值</li><li><code>use-credentials</code>：跨域请求要求用户身份</li></ul></li></ul></li><li><strong>方法：</strong><ul><li><code>onload</code>：加载完成</li><li><code>onerror</code>：加载失败</li></ul></li></ul>`,2);function _(N,A){const i=a("RouterLink"),c=a("ExternalLinkIcon");return s(),h("div",null,[p,e("ul",null,[e("li",null,[d(i,{to:"/FrontEnd/JavaScript/"},{default:t(()=>[o("JavaScript")]),_:1})]),e("li",null,[d(i,{to:"/FrontEnd/JavaScript/Events.html"},{default:t(()=>[o("Events")]),_:1})])]),n(' @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=5 orderedList=false} '),n(" code_chunk_output "),m,n(" /code_chunk_output "),g,e("ol",null,[e("li",null,[e("a",E,[o("JavaScript 操作 DOM 常用的 API"),d(c)])]),e("li",null,[e("a",f,[o("现代 JS 教程_DOM 查询"),d(c)])]),e("li",null,[e("a",b,[o("querySelector(All) 相比 getElement(s)By 在生产环境中有哪些优势？ 知乎"),d(c)])])]),M,e("p",null,[o("令见 "),d(i,{to:"/FrontEnd/JavaScript/Events.html"},{default:t(()=>[o("Events")]),_:1})]),B])}const x=r(u,[["render",_],["__file","DOM.html.vue"]]);export{x as default};
