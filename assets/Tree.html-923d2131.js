import{_ as e,V as o,W as c,$ as t,X as l,Z as n,a1 as a,a0 as s,D as i}from"./framework-94985248.js";const u="/assets/tree_unix-a0177ec0.png",r="/assets/tree_full_binary-55b0ebf6.png",k={},d=n("p",null,[n("br"),n("p",{style:{"font-size":"32px","font-weight":"bold"}},"目录")],-1),m=a('<ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul><li><a href="#%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%9C%AF%E8%AF%AD">概念及术语</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a><ul><li><a href="#%E6%80%A7%E8%B4%A8">性质</a></li><li><a href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F">遍历方式</a></li></ul></li><li><a href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91">普通二叉树</a><ul><li><a href="#%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89">节点定义</a></li><li><a href="#%E7%B1%BB%E5%AE%9A%E4%B9%89">类定义</a></li><li><a href="#%E6%9E%84%E5%BB%BA">构建</a></li><li><a href="#%E9%94%80%E6%AF%81">销毁</a></li><li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D">深拷贝</a></li><li><a href="#%E6%9F%A5%E6%89%BE">查找</a></li><li><a href="#%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9">插入新节点</a></li><li><a href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9">删除节点</a></li><li><a href="#%E9%AB%98%E5%BA%A6">高度</a></li></ul></li><li><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91">查找二叉树</a></li></ul>',1),v=a('<br><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>线性表，栈，队列，串，等等，都是一对一的<strong>线性结构</strong>，而 “树” 则是一种典型的非线性结构。非线性结构的特点就是，任意一个结点的直接前驱，如果存在，则一定是唯一的；直接后继如果存在，则可以有多个，也可以理解为一对多的关系</p><p>树这种数据结构有很多的应用：如操作系统的文件管理的结构就是一个树状的，从根目录(磁盘)开始一直套娃下去打开文件夹直至没有文件夹或找到目标文件(夹)、又如 <code>Json</code>、<code>yaml</code>这类的数据存储类型都可以看做是树</p><div align="center"><img width="70%" src="'+u+'"><p> Unix 的文件层次树 </p></div><p>正如 <strong>打开文件夹找文件</strong> 的过程而言，对树的遍历就是一个 <strong>递归</strong> 的过程（指只是点开下一个文件夹或返回键的情况下，毕竟在 GUI 下还可以直接点面包屑的节点跳转到先前节点），而内部对数据的存储的结构也是 <strong>不连续的连式存储</strong></p>',6),h=n("p",null,[s("在之前的线性结构的表中，要么插入时要 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("，要么访问时也要 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("，而 "),n("strong",null,"二叉查找树"),s(" 的大部分操作只要 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"log"),n("mo",null,"⁡"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(\\log{n})")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mop"},[s("lo"),n("span",{style:{"margin-right":"0.01389em"}},"g")]),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n")]),n("span",{class:"mclose"},")")])])]),s("。C++ STL 中的 "),n("code",null,"std::map"),s(" 和 "),n("code",null,"std::set"),s(" 正是用 "),n("strong",null,"红黑树"),s(" 来构造的")],-1),b=n("h3",{id:"概念及术语",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#概念及术语","aria-hidden":"true"},"#"),s(" 概念及术语")],-1),g=n("div",{class:"h5",id:"tree1"},"先在这里种一棵二叉树：",-1),y=a('<p>在这棵树中：</p><ul><li><strong>结点：</strong> 包含数据项以及指向其他结点的分支，例如上图中圆 A 中，既包含数据项 A 又指向 B 和 C 两个分支 <ul><li>特别的，因为 A 没有前驱，且有且只有一个，所以称其为<strong>根结点(root)</strong></li></ul></li><li><strong>子树：</strong> 由根结点以及根结点的所有后代导出的子图称为树的子树</li><li><strong>结点的度：</strong> 结点拥有子树的数目，简单的就是直接看有多少个分支，例如上图 A 的度为 2，B 的度为 1</li><li><strong>叶结点：</strong> 也叫作终端结点，即没有后继的结点，例如 E F G H I</li><li><strong>分支结点：</strong> 也叫作非终端结点，除叶结点之外的都可以这么叫</li><li><strong>孩子结点：</strong> 也叫作儿子结点，即一个结点的直接后继结点，例如 B 和 C 都是 A 的孩子结点</li><li><strong>双亲结点：</strong> 也叫作父结点，一个结点的直接前驱，例如 A 是 B 和 C 的双亲结点</li><li><strong>兄弟结点：</strong> 同一双亲的孩子结点互称为兄弟结点 例如 B 和 C 互为兄弟</li><li><strong>堂兄弟：</strong> 双亲互为兄弟结点的结点，例如 D 和 E 互为堂兄弟</li><li><strong>祖先结点：</strong> 从根结点到达一个结点的路径上的所有结点，A B D 结点均为 H 结点的祖先结点</li><li><strong>子孙结点：</strong> 以某个结点为根的子树中的任意一个结点都称为该结点的子孙结点，例如 C 的子孙结点有 E F I</li><li><strong>结点的层次：</strong> 设根结点层次为 1，其余结点为其双亲结点层次加 1，例如，A 层次为 1，B C 层次为 2</li><li><strong>树的高度：</strong> 也叫作树的<strong>深度(deep)</strong>，即树中结点的最大层次。这棵树就为 4</li><li><strong>有序/无序树：</strong> 树中结点子树是否从左到右为有</li></ul><br><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h2><h3 id="性质" tabindex="-1"><a class="header-anchor" href="#性质" aria-hidden="true">#</a> 性质</h3><p>二叉树（<strong>Binary tree</strong>）是每个结点<strong>最多只有两个分支</strong>（即不存在分支度大于 2 的结点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒</p><p>二叉树有以下几个性质：</p>',7),w=n("ul",null,[n("li",null,[s("性质 1：二叉树第 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"i")]),n("annotation",{encoding:"application/x-tex"},"i")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6595em"}}),n("span",{class:"mord mathnormal"},"i")])])]),s(" 层上的结点数目最多为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mrow",null,[n("mi",null,"i"),n("mo",null,"−"),n("mn",null,"1")])]),n("mo",{stretchy:"false"},"("),n("mi",null,"i"),n("mo",null,"≥"),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"2^{i-1} (i\\geq1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0747em","vertical-align":"-0.25em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8247em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mathnormal mtight"},"i"),n("span",{class:"mbin mtight"},"−"),n("span",{class:"mord mtight"},"1")])])])])])])])]),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≥"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])])]),n("li",null,[s("性质 2：深度为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"k")]),n("annotation",{encoding:"application/x-tex"},"k")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6944em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k")])])]),s(" 的二叉树至多有 $2k - 1 $个结点 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"("),n("mi",null,"k"),n("mo",null,"≥"),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"(k\\geq1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"≥"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])])]),n("li",null,[s("性质 3：包含 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"n")])])]),s(" 个结点的二叉树的高度至少为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mrow",null,[n("mi",null,"log"),n("mo",null,"⁡")]),n("mn",null,"2")]),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",null,"+"),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"\\log_{2}(n+1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mop"},[n("span",{class:"mop"},[s("lo"),n("span",{style:{"margin-right":"0.01389em"}},"g")]),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.207em"}},[n("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mtight"},"2")])])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.2441em"}},[n("span")])])])])]),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])])]),n("li",null,[s("性质 4：在任意一棵二叉树中，若叶子结点的个数为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"n"),n("mn",null,"0")])]),n("annotation",{encoding:"application/x-tex"},"n_0")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3011em"}},[n("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"0")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])])])])]),s("，度为 2 的结点数为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"n"),n("mn",null,"2")])]),n("annotation",{encoding:"application/x-tex"},"n_2")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3011em"}},[n("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])])])])]),s("，则 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"n"),n("mn",null,"0")]),n("mo",null,"="),n("msub",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",null,"+"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"n_0 = n_2+1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3011em"}},[n("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"0")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])]),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"="),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3011em"}},[n("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])]),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])])])],-1),f=a('<div class="h5">分类</div><p>完全二叉树就是满二叉树的改版：不再要求一定有两个节点，但节点出现的顺序必须是按照满二叉树的情况来的</p><p>查找二叉树就是规定了在构造二叉树的时候左子节点必须大于父节点，右子节点必须小于其父节点</p><div align="center"><img width="70%" src="'+r+`"><p> 完全二叉树与满二叉树 </p></div><h3 id="遍历方式" tabindex="-1"><a class="header-anchor" href="#遍历方式" aria-hidden="true">#</a> 遍历方式</h3><p>与之前的线性表不同，树状结构的遍历是完全不一样的，但也很好理解。比如说，想在文件管理器中找某个文件（如 <code>D:\\Gits\\FishCode\\CPP\\DataStruct\\Tree</code>），通常步骤都是从根目录(磁盘名)开始，按路径一路点进去(深入)，直到找到或没有文件夹为止</p><p>那么树状结构都可以用类似这样的方式去遍历，对于二叉树来讲，主要有四种遍历方式：</p><ul><li><strong>先序遍历（根-&gt;左-&gt;右）：</strong> 从根节点开始，一直向左节点深入直到空，并访问(或输出)，到空时访问兄弟的右节点。如果右节点为空则向上回溯直到非空右节点，然后再继续向左访问</li><li><strong>中序遍历（左-&gt;根-&gt;右）：</strong> 从根节点开始，一直向左节点深入直到空，但并不访问(输出)，到空时才访问该左节点，然后是根节点，如果右节点还有孩子则再继续重复</li><li><strong>后序遍历（左-&gt;右-&gt;根）：</strong> 也是先一直向左节点深入直到空，也是到空时才访问左节点，然后如果右节点有孩子则再继续了</li><li><strong>层序遍历：</strong> 从上到下，从左到右地对每一层的节点进行访问</li></ul><blockquote><p>所以这样的过程很容易用 递归 和 分治 的方法去实现</p></blockquote><p>以 <a href="#tree1">开头种的树</a> 举例：四种遍历的结果分别是</p><ul><li><code>A B D G H C E F I</code></li><li><code>G D H B A E C F I</code></li><li><code>G H D B E I F C A</code></li><li><code>A B C D E F G H I</code></li></ul><p>那实现起来就是（节点的定义见<a href="#%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89">下</a>）：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 前序遍历</span>
<span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> tree<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 中序遍历</span>
<span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> tree<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 后序遍历</span>
<span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> tree<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 层序遍历</span>
<span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  queue<span class="token operator">&lt;</span>Node <span class="token operator">*</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
  Node <span class="token operator">*</span>p <span class="token operator">=</span> tree<span class="token punctuation">;</span>
  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
      q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
      q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归实现起来特别直观，因为每一个节点都可以看做是该节点子树的根节点，那么只要把根节点输出就好了</p><p>而由于递归本质上就是栈的调用，那也是能用栈去实现的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 前序遍历</span>
<span class="token keyword">void</span> <span class="token function">preStack</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  stack<span class="token operator">&lt;</span>Node <span class="token operator">*</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
  Node <span class="token operator">*</span>p <span class="token operator">=</span> tree<span class="token punctuation">;</span>
  <span class="token comment">// 直到遍历完树且栈中无节点为止</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 向左边深入，直到左叶子</span>
    <span class="token comment">// 入栈是为了记录深入过程中的 根节点</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 输出根节点</span>
      cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
      s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
      p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 出栈是回退到上一个节点，然后向右边深入</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      p <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 中序遍历</span>
<span class="token keyword">void</span> <span class="token function">inStack</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  stack<span class="token operator">&lt;</span>Node <span class="token operator">*</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
  Node <span class="token operator">*</span>p <span class="token operator">=</span> tree<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先深入到左叶子，与前序遍历不同的是，深入到空再输出</span>
    <span class="token comment">// 而不是边深入边输出根节点</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
      p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 弹出左节点或是说该叶子节点，然后向右深入</span>
      p <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
      s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">postStack</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  stack<span class="token operator">&lt;</span>Node <span class="token operator">*</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
  Node <span class="token operator">*</span>cur<span class="token punctuation">,</span> <span class="token operator">*</span>pre <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cur <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 深入到叶子节点时就可以输出了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
      <span class="token comment">// 或者非叶子节点，但已访问过左节点，轮到右节点了</span>
      <span class="token comment">// 就要记录下上一个访问的节点</span>
      <span class="token operator">||</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">// 排除掉第一次</span>
        <span class="token punctuation">(</span>pre <span class="token operator">==</span> cur<span class="token operator">-&gt;</span>left <span class="token operator">||</span> pre <span class="token operator">==</span> cur<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
      s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 基于栈，所以先入右边才能让左节点先被访问</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h2 id="普通二叉树" tabindex="-1"><a class="header-anchor" href="#普通二叉树" aria-hidden="true">#</a> 普通二叉树</h2><h3 id="节点定义" tabindex="-1"><a class="header-anchor" href="#节点定义" aria-hidden="true">#</a> 节点定义</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">BNode</span> <span class="token punctuation">{</span>
  T data<span class="token punctuation">;</span>
  BNode <span class="token operator">*</span>left<span class="token punctuation">;</span>
  BNode <span class="token operator">*</span>right<span class="token punctuation">;</span>

  <span class="token function">BNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>x <span class="token operator">=</span> T<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> BNode <span class="token operator">*</span>l <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> BNode <span class="token operator">*</span>r <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span>
    data<span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">,</span> left<span class="token punctuation">{</span>l<span class="token punctuation">}</span><span class="token punctuation">,</span> right<span class="token punctuation">{</span>r<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类定义" tabindex="-1"><a class="header-anchor" href="#类定义" aria-hidden="true">#</a> 类定义</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Tree</span> <span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token keyword">typedef</span> BNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>

  Node <span class="token operator">*</span>root<span class="token punctuation">;</span>
  T nullNode<span class="token punctuation">;</span>
  <span class="token keyword">int</span> len<span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">buildPreInput</span><span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">buildPreIn</span><span class="token punctuation">(</span>T pre<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">preStack</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">inStack</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">postStack</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  Node <span class="token operator">*</span><span class="token function">copy</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">bool</span> <span class="token function">equal</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>a<span class="token punctuation">,</span> Node <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  Node <span class="token operator">*</span><span class="token function">find</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  Node <span class="token operator">*</span><span class="token function">findPar</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">bool</span> <span class="token function">modify</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">bool</span> <span class="token function">exist</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">bool</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">bool</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">,</span> Node <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">bool</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">bool</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">Tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>nullNode<span class="token punctuation">{</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> len<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">explicit</span> <span class="token function">Tree</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token operator">:</span>nullNode<span class="token punctuation">{</span>e<span class="token punctuation">}</span><span class="token punctuation">,</span> len<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">//树节点的个数</span>
  <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 树的高度</span>
  <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 销毁整棵树</span>
  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 深拷贝一棵树</span>
  <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token keyword">const</span> Tree <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 反转一棵树</span>
  <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 判断两棵树是否相等</span>
  <span class="token keyword">bool</span> <span class="token function">equal</span><span class="token punctuation">(</span><span class="token keyword">const</span> Tree <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 查找树中的节点是否存在</span>
  T <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 查找该节点的父节点，存在则返回父节点的值，否则返回-1</span>
  T <span class="token function">findPar</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 将 x 修改为 value</span>
  <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 在指定节点和方向插入值</span>
  <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">bool</span> l <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 在指定节点和方向插入子树</span>
  <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> Tree <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">bool</span> l <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 删除节点</span>
  <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 带空节点标记的先序遍历创建二叉树（输入流）</span>
  <span class="token keyword">void</span> <span class="token function">buildPreInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 先序遍历和中序遍历构造二叉树</span>
  <span class="token keyword">void</span> <span class="token function">buildPreIn</span><span class="token punctuation">(</span>T pre<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 后序遍历和中序遍历构造二叉树</span>
  <span class="token keyword">void</span> <span class="token function">buildPostIn</span><span class="token punctuation">(</span>T post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 先序遍历输出</span>
  <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 非递归先序遍历输出</span>
  <span class="token keyword">void</span> <span class="token function">preStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 中序遍历输出</span>
  <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 非递归中序遍历输出</span>
  <span class="token keyword">void</span> <span class="token function">inStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 后序遍历输出</span>
  <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 非递归后序遍历输出</span>
  <span class="token keyword">void</span> <span class="token function">postStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 层次遍历输出</span>
  <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="构建" tabindex="-1"><a class="header-anchor" href="#构建" aria-hidden="true">#</a> 构建</h3><p>从头开始构建一颗二叉树，可以使用先序遍历地方式，并指定空节点的形式(如 <code>#</code>)。以 <a href="#tree1">开头种的树</a> 来讲就是 <code>A B D G # # H # # # C E # # F # I # #</code></p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">buildPreInput</span><span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  T x<span class="token punctuation">;</span>
  cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> nullNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tree <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token operator">++</span>len<span class="token punctuation">;</span>
  tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">buildPreInput</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">buildPreInput</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><p>由于中序遍历规定了左右节点相对于根节点的位置，先序和后序确定了根节点相对于左右节点的位置，因而用中序遍历与 先序遍历和后序遍历中的一个 结合，就能确定一颗二叉树</p><p>还是拿 以 <a href="#tree1">开头种的树</a> 来说</p><div class="h5">先序遍历和中序遍历创建二叉树</div><p>结合中序遍历与先序遍历</p><div style="text-align:center;margin:1rem;"><p><span></span></p><table><thead><tr><th style="text-align:center;">先序遍历</th><th style="text-align:center;">A</th><th style="text-align:center;">B</th><th style="text-align:center;">D</th><th style="text-align:center;">G</th><th style="text-align:center;">H</th><th style="text-align:center;">C</th><th style="text-align:center;">E</th><th style="text-align:center;">F</th><th style="text-align:center;">I</th></tr></thead><tbody><tr><td style="text-align:center;">中序遍历</td><td style="text-align:center;">G</td><td style="text-align:center;">D</td><td style="text-align:center;">H</td><td style="text-align:center;">B</td><td style="text-align:center;">A</td><td style="text-align:center;">E</td><td style="text-align:center;">C</td><td style="text-align:center;">F</td><td style="text-align:center;">I</td></tr></tbody></table></div><p>在中序遍历中，根节点 A 的左边都是左子树，右边都是右子树，其他的也是这样。而每个子树的左右字节点在中序遍历中的左右两边，这样很难不想到使用 <strong>分治算法</strong> 来构建。而之所以先从左子树开始，是因为先序遍历的顺序就是 根左右</p><p>而每次分治的边界都应该是属于子树的范围，如：</p>`,33),x=n("ul",null,[n("li",null,[s("一开始的范围是 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"["),n("mi",null,"G"),n("mo",{separator:"true"},","),n("mi",null,"I"),n("mo",{stretchy:"false"},"]")]),n("annotation",{encoding:"application/x-tex"},"[G, I]")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"["),n("span",{class:"mord mathnormal"},"G"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.07847em"}},"I"),n("span",{class:"mclose"},"]")])])])]),n("li",null,[s("下一步到左节点，范围被分分割成了 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"["),n("mi",null,"G"),n("mo",{separator:"true"},","),n("mi",null,"B"),n("mo",{stretchy:"false"},"]")]),n("annotation",{encoding:"application/x-tex"},"[G, B]")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"["),n("span",{class:"mord mathnormal"},"G"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B"),n("span",{class:"mclose"},"]")])])]),s("，也就是在这个范围内都是根节点 A 的左子树")]),n("li",null,[s("再下一步是 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"p"),n("mi",null,"r"),n("mi",null,"e"),n("mo",{stretchy:"false"},"["),n("mn",null,"1"),n("mo",{stretchy:"false"},"]"),n("mo",null,"→"),n("mi",null,"B")]),n("annotation",{encoding:"application/x-tex"},"pre[1] \\to B")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"p"),n("span",{class:"mord mathnormal"},"re"),n("span",{class:"mopen"},"["),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},"]"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"→"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6833em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B")])])]),s("，范围为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"["),n("mi",null,"G"),n("mo",{separator:"true"},","),n("mi",null,"H"),n("mo",{stretchy:"false"},"]")]),n("annotation",{encoding:"application/x-tex"},"[G, H]")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"["),n("span",{class:"mord mathnormal"},"G"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.08125em"}},"H"),n("span",{class:"mclose"},"]")])])])]),n("li",null,[s("当轮到 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"p"),n("mi",null,"r"),n("mi",null,"e"),n("mo",{stretchy:"false"},"["),n("mn",null,"5"),n("mo",{stretchy:"false"},"]"),n("mo",null,"→"),n("mi",null,"C")]),n("annotation",{encoding:"application/x-tex"},"pre[5] \\to C")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"p"),n("span",{class:"mord mathnormal"},"re"),n("span",{class:"mopen"},"["),n("span",{class:"mord"},"5"),n("span",{class:"mclose"},"]"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"→"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6833em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C")])])]),s(" 时，始终在上一个范围 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"["),n("mi",null,"H"),n("mo",{separator:"true"},","),n("mi",null,"H"),n("mo",{stretchy:"false"},"]")]),n("annotation",{encoding:"application/x-tex"},"[H, H]")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"["),n("span",{class:"mord mathnormal",style:{"margin-right":"0.08125em"}},"H"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.08125em"}},"H"),n("span",{class:"mclose"},"]")])])]),s(" 中找不到 C，说明在根节点的左子树已经遍历完了，就只能一层层地向上回溯，一直到根节点的范围 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"["),n("mi",null,"G"),n("mo",{separator:"true"},","),n("mi",null,"I"),n("mo",{stretchy:"false"},"]")]),n("annotation",{encoding:"application/x-tex"},"[G, I]")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"["),n("span",{class:"mord mathnormal"},"G"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.07847em"}},"I"),n("span",{class:"mclose"},"]")])])]),s("，然后再继续")])],-1),N=a(`<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">buildPreIn</span><span class="token punctuation">(</span>T pre<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 先找到先序在中序中的位置</span>
  <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pre<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flag <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token comment">// 如果在这个范围内找不到，说明就要向上回溯去扩大范围了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>in<span class="token punctuation">[</span>flag<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">++</span>t<span class="token punctuation">;</span>

  <span class="token comment">// 分治</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">buildPreIn</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> in<span class="token punctuation">,</span> l<span class="token punctuation">,</span> flag <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">buildPreIn</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> in<span class="token punctuation">,</span> flag <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> t<span class="token punctuation">,</span> tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// in public:</span>
<span class="token keyword">void</span> <span class="token function">buildPreIn</span><span class="token punctuation">(</span>T pre<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 默认下标从 0 开始</span>
  <span class="token function">buildPreIn</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> in<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="h5">后序遍历与中序遍历创建二叉树</div><p>其实能发现，后序遍历反过来时是 <em>根右左</em>，对于先序遍历来说就是交换了左右子树（翻转），那么只要在先序遍历的基础上，先右后左地分治就好了</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">buildPostIn</span><span class="token punctuation">(</span>T post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> post<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flag <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>in<span class="token punctuation">[</span>flag<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">--</span>t<span class="token punctuation">;</span>

  <span class="token comment">// 反过来了，根右左</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">buildPostIn</span><span class="token punctuation">(</span>post<span class="token punctuation">,</span> in<span class="token punctuation">,</span> flag <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> t<span class="token punctuation">,</span> tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">buildPostIn</span><span class="token punctuation">(</span>post<span class="token punctuation">,</span> in<span class="token punctuation">,</span> l<span class="token punctuation">,</span> flag <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// in public:</span>
<span class="token keyword">void</span> <span class="token function">buildPostIn</span><span class="token punctuation">(</span>T post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> n <span class="token operator">=</span> len<span class="token punctuation">;</span> <span class="token comment">// 从后往前遍历后序遍历</span>
  <span class="token function">buildPostIn</span><span class="token punctuation">(</span>post<span class="token punctuation">,</span> in<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="销毁" tabindex="-1"><a class="header-anchor" href="#销毁" aria-hidden="true">#</a> 销毁</h3><p>也就是释放节点内存，其实只要按照 左右根 也就是后续遍历的样子来就行了</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">destroy</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">destroy</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">--</span>len<span class="token punctuation">;</span>
  <span class="token keyword">delete</span> tree<span class="token punctuation">;</span> tree <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="深拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝" aria-hidden="true">#</a> 深拷贝</h3><p>类似先序遍历那样吧</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Node <span class="token operator">*</span><span class="token function">copy</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

  Node <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  newNode<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  newNode<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h3><p>其实还是先序遍历的思路，一直深入到空，值相等才返回</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Node <span class="token operator">*</span><span class="token function">find</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> tree<span class="token operator">-&gt;</span>data <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> tree<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// for C++ 17</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 左节点没子树后就向右查找</span>
    <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 查找父节点</span>
Node <span class="token operator">*</span><span class="token function">findPar</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> tree<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>data <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> tree<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>data <span class="token operator">==</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> tree<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">findPar</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">findPar</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="插入新节点" tabindex="-1"><a class="header-anchor" href="#插入新节点" aria-hidden="true">#</a> 插入新节点</h3><p>由于本身没太多限制，所以插入时还需要指定被插入的节点和插入的方向，于是就得先找到节点，然后还得判断插入方向是否已经存在节点了</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">exist</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">bool</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\\n----没有这个节点，或已有左右子树----\\n&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">bool</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Node <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>tree<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  Node <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">)</span> p<span class="token operator">-&gt;</span>left <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
  <span class="token keyword">else</span> p<span class="token operator">-&gt;</span>right <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 插入一颗子树</span>
<span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">,</span> Node <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">bool</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Node <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>tree<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exist</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 而插入子树时必须得深拷贝出来</span>
  Node <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">)</span> p<span class="token operator">-&gt;</span>left <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
  <span class="token keyword">else</span> p<span class="token operator">-&gt;</span>right <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="删除节点" tabindex="-1"><a class="header-anchor" href="#删除节点" aria-hidden="true">#</a> 删除节点</h3><p>不同的是，这里需要找到节点的父节点</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Node <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">findPar</span><span class="token punctuation">(</span>tree<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">destroy</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">destroy</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="高度" tabindex="-1"><a class="header-anchor" href="#高度" aria-hidden="true">#</a> 高度</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">height</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">height</span><span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;</span> r <span class="token operator">?</span> l <span class="token operator">:</span> r<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h2 id="完全二叉树" tabindex="-1"><a class="header-anchor" href="#完全二叉树" aria-hidden="true">#</a> 完全二叉树</h2><br><h2 id="查找二叉树" tabindex="-1"><a class="header-anchor" href="#查找二叉树" aria-hidden="true">#</a> 查找二叉树</h2>`,26);function E(B,T){const p=i("Mermaid");return o(),c("div",null,[d,t(' @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=5 orderedList=false} '),t(" code_chunk_output "),m,t(" /code_chunk_output "),v,h,b,g,l(p,{id:"mermaid-120",code:"eJxVyzsOwkAMhOHep9jyT7ESHGG9754LUEERRQiJ+zOJIiTcfLZH83jfX89wc0uQlsUcXGTIokARFapo0ESHLgYMMWEKSzFGtxBcltPtAttnXZUHTdGr/7ZxVLLuLOtpO/K2l69/5f017QuRQyEw"}),y,w,f,x,N])}const A=e(k,[["render",E],["__file","Tree.html.vue"]]);export{A as default};
