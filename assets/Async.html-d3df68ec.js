import{_ as e,V as o,W as l,$ as s,Z as a,a1 as t,a0 as n}from"./framework-94985248.js";const c={},p=a("p",null,[a("br"),a("p",{style:{"font-size":"32px","font-weight":"bold"}},"目录")],-1),r=t('<ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul><li><a href="#%E7%BB%8F%E5%85%B8%E6%95%85%E4%BA%8B">经典故事</a></li><li><a href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E">阻塞与非阻塞</a></li><li><a href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5">同步与异步</a></li></ul></li><li><a href="#javascript-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%A1%88">JavaScript 实现异步的方案</a><ul><li><a href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">回调函数</a></li></ul></li></ul>',1),i=t('<br><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><h3 id="经典故事" tabindex="-1"><a class="header-anchor" href="#经典故事" aria-hidden="true">#</a> 经典故事</h3><p>老张有两个水壶：普通水壶、烧开后会响的水壶</p><ul><li><strong>同步阻塞：</strong> 老张把水壶放到火上，立等水开</li><li><strong>同步非阻塞：</strong> 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有</li><li><strong>异步阻塞：</strong> 老张把响水壶放到火上，立等水开</li><li><strong>异步非阻塞：</strong> 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶</li></ul><p><strong>所谓同步异步，只是对于水壶而言</strong>。 普通水壶，同步；响水壶，异步</p><ul><li>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了（<strong>完成后的消息</strong>）</li><li>同步只能让调用者去 <strong>轮询</strong> 自己，造成老张效率的低下</li></ul><p><strong>所谓阻塞非阻塞，仅仅对于老张而言</strong>。 干等的老张，阻塞；看电视的老张，非阻塞</p><ul><li>情况 1 和情况 3 中老张就是阻塞的，只能等当前事件完成后才能干别的，媳妇喊他都不知道</li><li>虽然 3 中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般<strong>异步是配合非阻塞使用的</strong>，这样才能发挥异步的效用</li></ul><br><h3 id="阻塞与非阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞与非阻塞" aria-hidden="true">#</a> 阻塞与非阻塞</h3><p>阻塞和非阻塞是从 <strong>程序（线程）等待消息通知（无所谓同步或者异步）时的状态</strong> 的角度来说的，关注的是程序在等待调用结果（消息、返回值）时的状态</p><ul><li><strong>阻塞调用</strong> 是指调用结果返回之前，当前线程会被<strong>挂起</strong>，专注于完成当前线程。调用线程只有在等到结果之后才会返回</li><li><strong>非阻塞调用</strong> 指在不能立刻得到结果之时，该调用不会阻塞当前线程，而是可以继续执行别的进程</li></ul><br><h3 id="同步与异步" tabindex="-1"><a class="header-anchor" href="#同步与异步" aria-hidden="true">#</a> 同步与异步</h3><div class="h5">同步：</div><p>所谓同步，就是发出一个功能调用时，在得到结果之前，该调用就不返回或继续执行后续操作。 简单来说，<strong>同步就是必须一件一件事做，等前一件做完了才能做下一件事</strong></p><blockquote><p>例如：B/S 模式中的表单提交，具体过程是：客户端提交请求-&gt;等待服务器处理-&gt;处理完毕返回，在这个过程中客户端（浏览器）不能做其他事</p></blockquote><div class="h5">异步：</div><p>异步与同步相对，当一个异步过程调用发出后，调用者在得到结果之前，就可以继续执行后续操作。调用者一般通过状态、通知和回调来了解调用的执行情况：</p><ul><li><strong>状态：</strong> 即监听被调用者的状态（<strong>轮询</strong>），调用者需要每隔一定时间检查一次，效率会很低</li><li><strong>通知：</strong> 当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能</li><li><strong>回调：</strong> 与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数</li></ul><blockquote><p>例如：B/S 模式中的 ajax 请求，具体过程是：客户端发出 ajax 请求-&gt;服务端处理-&gt;处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事</p></blockquote><div class="h5">场景：</div><p>假设有多个耗时的操作，如果都用同步的方式去运行，那总的耗时就是<strong>所有耗时的和</strong>；但如果用异步的方式去运行，那总的耗时就是当中<strong>最大的耗时</strong></p><p>同步就在于为了<strong>按代码编写的顺序</strong>去执行，而异步就是为了<strong>按时间的顺序</strong>去执行</p><br><h2 id="javascript-实现异步的方案" tabindex="-1"><a class="header-anchor" href="#javascript-实现异步的方案" aria-hidden="true">#</a> JavaScript 实现异步的方案</h2><p>众所周知， Javascript 语言的执行环境是 “单线程”，也就是<strong>指一次只能完成一件任务</strong>。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务</p><p>这种模式虽然实现起来比较简单，执行环境相对单纯，但是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。<strong>此时解决任务的总时长为所有任务时长的和</strong></p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），<strong>不得不等着结果出来，再往下执行</strong></p><blockquote><p>常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行</p></blockquote><p>但其实这时候 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的 “事件循环”机制（Event Loop）</p>',32),u=a("p",null,[n("在通常情况下，JavaScript 是可以同步地按顺序执行的，但一旦涉及了 "),a("code",null,"setTimeout"),n("、文件 IO、网络请求等操作，JavaScript 就会把他们当做异步了。这时，它会先把异步的函数推入一个任务队列中，等所有同步的函数执行完后再执行异步的，耗时为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"m"),a("mi",null,"a"),a("mi",null,"x"),a("mo",{stretchy:"false"},"("),a("mtext",null,"异步时间"),a("mo",{stretchy:"false"},")"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(max(\\text{异步时间}))")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"ma"),a("span",{class:"mord mathnormal"},"x"),a("span",{class:"mopen"},"("),a("span",{class:"mord text"},[a("span",{class:"mord cjk_fallback"},"异步时间")]),a("span",{class:"mclose"},"))")])])]),n("。如")],-1),d=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    data <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> aa <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">c</span><span class="token punctuation">(</span>aa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设想是先执行c里的 += 100 再输出</span>
<span class="token comment">// 但输出 b: 23</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原因就在于函数 c 中的 <code>setTimeout</code> 导致了这个语句被放到了异步队列，在 <code>data += 100</code> 之前就直接 <code>return data;</code> 了，所以就还是输出了 23</p><p>但实际上设想的是 <strong>按时间顺序</strong> 地 1 秒后 += 100，再返回。所以，当使用了异步操作的时候，就要用专门的异步的方式去执行。通常有以下几种来实现异步：</p><br><h3 id="回调函数" tabindex="-1"><a class="header-anchor" href="#回调函数" aria-hidden="true">#</a> 回调函数</h3>`,5);function h(m,g){return o(),l("div",null,[p,s(' @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=5 orderedList=false} '),s(" code_chunk_output "),r,s(" /code_chunk_output "),i,u,d])}const v=e(c,[["render",h],["__file","Async.html.vue"]]);export{v as default};
