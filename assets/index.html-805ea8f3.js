import{_ as i,V as d,W as r,Z as n,X as a,Y as c,$ as p,a0 as s,a1 as o,D as l}from"./framework-94985248.js";const u="/assets/Node_package-1a88b86a.png",k={},m=n("p",{style:{"font-size":"32px","font-weight":"bold"}},"目录",-1),v=o('<ul><li><a href="#node-%E9%A1%B9%E7%9B%AE">Node 项目</a><ul><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li></ul></li><li><a href="#%E6%A8%A1%E5%9D%97">模块</a><ul><li><a href="#common-js-%E4%B8%8E-es-modules">Common JS 与 ES Modules</a></li><li><a href="#buffer-%E7%BC%93%E5%86%B2%E5%8C%BA">Buffer 缓冲区</a></li><li><a href="#path-%E8%B7%AF%E5%BE%84">Path 路径</a></li><li><a href="#fs-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">fs 文件读写</a></li><li><a href="#express-%E6%A1%86%E6%9E%B6">Express 框架</a></li></ul></li></ul>',1),h=o(`<br><blockquote><p><strong>一些默认的约定：</strong> 下文的 js 文件的工作目录（即 IDE 或命令行打开的目录）为 <code>D:\\Node</code>，文件路径为<code>D:\\Node\\src\\index.js</code>，若无说明，代码的单行注释为该行的输出</p></blockquote><br><h2 id="node-项目" tabindex="-1"><a class="header-anchor" href="#node-项目" aria-hidden="true">#</a> Node 项目</h2><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h3><ul><li>cd 到项目文件夹并运行 ↓ 后，按提示填写项目信息，就会生成 <code>package.json</code> 文件<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">pnpm</span> init
<span class="token comment"># 选默认值则是:</span>
<span class="token function">pnpm</span> init <span class="token parameter variable">-y</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>package.json</code> 文件包含的信息：</li></ul><div align="center"><img width="80%" src="`+u+'"><p> 配置信息 </p></div><br>',8),f=n("p",null,[s("其中最后的 "),n("code",null,"type"),s(" 字段是涉及到模块规范的支持，它有两个可选值： "),n("code",null,"commonjs"),s(" 和 "),n("code",null,"module"),s(" ，其默认值为 "),n("code",null,"commonjs")],-1),g=n("code",null,"package.json",-1),b={href:"https://docs.npmjs.com/cli/v8/configuring-npm/package-json/",target:"_blank",rel:"noopener noreferrer"},_=n("code",null,"nodemon",-1),j={href:"https://nodemon.io/",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.jianshu.com/p/a35dfc72c6e6",target:"_blank",rel:"noopener noreferrer"},E=o(`<div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;dev&quot;</span><span class="token operator">:</span> <span class="token string">&quot;nodemon --experimental-specifier-resolution=node --ignore ./static --delay 3s ./src&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),w={href:"https://blog.csdn.net/sayUonly/article/details/122885171",target:"_blank",rel:"noopener noreferrer"},y={href:"https://blog.csdn.net/muguli2008/article/details/122246623",target:"_blank",rel:"noopener noreferrer"},B={href:"https://segmentfault.com/q/1010000039917414",target:"_blank",rel:"noopener noreferrer"},N=o(`<br><h2 id="模块" tabindex="-1"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h2><h3 id="common-js-与-es-modules" tabindex="-1"><a class="header-anchor" href="#common-js-与-es-modules" aria-hidden="true">#</a> Common JS 与 ES Modules</h3><ul><li><p><strong><code>CommonJS</code>：</strong></p><ul><li><strong>导出：</strong> CJS 使用 <code>module.exports = {}</code> 语法导出模块，可以导出任意合法的 <code>JavaScript</code> 类型，例如：字符串、布尔值、对象、数组、函数等等</li><li><strong>导入：</strong> 使用 <code>require</code> 导入模块，在导入的时候，当文件扩展名是 <code>.js</code> 时，可以只写文件名</li></ul></li><li><p><strong><code>ESModules</code>：</strong> 要引入 <code>package.json</code> 并设置 <code>&quot;type&quot;: &quot;module&quot;</code></p><ul><li><strong>导出：</strong> 在要导出的 js 类型前加 <code>export</code></li><li><strong>导入：</strong> <code>import {} from &#39;./module&#39;</code>，重命名：<code>{mie as miemie}</code></li><li><strong>但这样运行时要加上</strong> <code>node --experimental-specifier-resolution=node dir</code> 才能忽略后缀名地使用 ES 模块</li></ul></li><li><p><strong>在 ES 模块下的 <code>__dirname</code>：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> fileURLToPath <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;url&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">&#39;path&#39;</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span>  <span class="token parameter">metaUrl</span> i<wbr>mport.meta.url
 * <span class="token keyword">@returns</span> <span class="token class-name"><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span> the path
 */</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">dirname</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">metaUrl</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span><span class="token function">fileURLToPath</span><span class="token punctuation">(</span>metaUrl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// to use (after import):</span>
<span class="token function">dirname</span><span class="token punctuation">(</span><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// D:\\Node\\src</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><br><h3 id="buffer-缓冲区" tabindex="-1"><a class="header-anchor" href="#buffer-缓冲区" aria-hidden="true">#</a> Buffer 缓冲区</h3><p><code>Buffer</code> 是 <code>Node.js</code> 的内置类型，它是用来表示内存中一块区域的，用以保存二进制数据。内容是以将二进制文件流表现为十六进制的 Buffer 数组</p><p><code>Buffer</code> 可以用来表示图片、视频这样的二进制数据，另外我们从文件中读取到的也是 <code>Buffer</code> 类型的数据，从网络中接收的数据也是 Buffer 类型的数据</p><ul><li><strong>一些方法：</strong><ul><li><code>Buffer.alloc(len)</code>：开辟一个 len 个字节的内存</li><li><code>Buffer.from(x)</code>：将字符串或数组转为 <code>Buffer</code> 对象，范围为 <code>00 ~ 0xff</code></li><li><code>Buffer.toString(decode)</code>：将 <code>buffer</code> 对象转换为指定编码字符串，默认为 <code>utf8</code></li></ul></li></ul><br><h3 id="path-路径" tabindex="-1"><a class="header-anchor" href="#path-路径" aria-hidden="true">#</a> Path 路径</h3><p>path 模块包含了一些列处理和转换文件路径的工具集。其中，在 Windows 下，目录的分隔符为 <code>\\</code>，UNIX 下，分隔符为 <code>/</code></p><div class="h5">方法：</div><ul><li><code>path.resolve([path1], [path2], ...)</code>： 按照顺序依次拼接，返回的是 <strong>绝对路径</strong>，路径末尾的不会带有路径分隔符。若合并后的路径没有构成一个绝对路径，则会默认使用 <strong>当前工作目录的绝对路径</strong><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// D:\\Node</span>
path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;path1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;path2/&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// D:\\Node\\path1\\path2</span>
path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;F:\\\\path1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;path2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// F:\\path1\\path2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>path.join([path1], [path2], ...)</code>：与 <code>resolve</code> 的区别在于，仅是拼接路径，不会强制转换成绝对路径，末尾可带路径分隔符<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// .</span>
path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;path1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;path2/&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// path1\\path2\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>path.relative(from, to)</code>：返回两个路径的相对关系<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;mie/mie/&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;haha&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ..\\..\\haha</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><code>path.parse(path)</code>：返回该路径的路径对象，包括根目录、到该目录（文件）的目录，目录（文件）名、文件后缀、文件名<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>path<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>__filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*path:  {
  root: &#39;D:\\\\&#39;,
  dir: &#39;D:\\\\Node\\\\src&#39;,
  base: &#39;index.js&#39;,
  ext: &#39;.js&#39;,
  name: &#39;index&#39;
}*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>path.dirname(path)</code>：返回该文件（夹）的路径<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>__filename<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// D:\\Node\\src</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><code>path.basename(path)</code>：返回该文件（夹）的名称（不含路径）</li><li><code>path.extname(path)</code>：返回文件的后缀，无后缀则返回 <code>&#39;&#39;</code></li></ul><br><h3 id="fs-文件读写" tabindex="-1"><a class="header-anchor" href="#fs-文件读写" aria-hidden="true">#</a> fs 文件读写</h3><p><strong>文件写入：</strong> 如果不存在这个文件名，这会创建文件</p><ul><li><strong>简单写入：</strong><ul><li><code>fs.writeFile(file, data, [,options], callback);</code>，存在该文件时会覆盖原内容</li><li><code>options</code> 选项 <ol><li><code>encoding</code> 默认值: <code>&#39;utf8&#39;</code></li><li><code>mode</code> 默认值: <code>0o666</code></li><li><code>flag</code> 默认值: <code>&#39;w&#39;</code></li></ol></li></ul></li><li><strong>流式写入：</strong> <code>fs.createWriteStream(path[, options])</code><ul><li>事件监听 <code>open | close</code> eg: <code>ws.on(&#39;open&#39;, callback(err));</code></li></ul></li><li><strong>追加写入：</strong> <code>fs.appendFile(path, data, callback(err))</code></li></ul><p><strong>文件读取：</strong> 返回的 data 为 Buffer 类型</p><ul><li><code>fs.readFile(file, callback(err, data))</code></li><li>大文件用流式读取： <code>fs.createReadStream(file)</code></li></ul><div class="h5">文件删除和复制：</div><ul><li><code>fs.unlink(path, callback(err));</code>：删除文件或符号链接</li><li><code>fs.rm(path[, options], callback(err))</code>：删除目录和文件，其中 <code>options: {recursive: true}</code> 执行递归删除嵌套目录</li><li><code>fs.copyFile(from, to[, mode], callback(err))</code>：复制文件，但： <ul><li>只能复制文件，不能复制目录</li><li>目标目录不存在则不会创建并报错</li><li>文件类型可以不一致</li></ul></li></ul><div class="h5">重命名：</div><ul><li><code>fs.rename(oldPath, newPath, callback(err))</code>，重命名，但： <ul><li>不能重命名目录，只能重命名文件</li><li>如果重命名文件已存在将被覆盖</li></ul></li></ul><div class="h5">文件夹操作：</div><ul><li><code>fs.mkdir(path[, options], callback(err, path))</code>：创建文件夹 <ul><li>其中的 <code>options</code> 有两个参数： <ol><li><code>recursive</code> 是否以递归的方式创建目录（<strong>创建嵌套目录</strong>），默认为 <code>false</code></li><li><code>mode</code> 设置目录权限权限 默认为 0777（<strong>WIndows 不支持</strong>）</li></ol></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>fs<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token string">&#39;./mie/fish&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">recursive</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> path</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// D:\\Node\\mie</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>fs.readdir(path[, options], callback(err, files))</code>：读取文件夹 <ul><li><code>options</code> 可以是指定编码格式的字符串，也可以是具有以下属性的对象 <ul><li><code>encoding</code>：：指定编码格式，默认值： <code>utf-8</code></li><li><code>withFileTypes</code>： files 数组是否包含 <code>&lt;fs.Dirent&gt;</code> 对象，默认值： false</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>fs<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> files</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
  <span class="token keyword">else</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&#39;index.js&#39;, &#39;mie&#39;]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><strong>获取文件信息：</strong> <code>fs.stat(file)</code></p><br><p><strong>以上均为带回调函数的异步写法</strong>，换成同步写法只需在方法名后加 <code>Sync</code>，回调的数据通过 <code>return</code> 的形式返回出去，同时必须带上 <strong>异常处理</strong>，免得整个程序宕机了</p><ul><li><strong>如：</strong><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> p <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;../static/data.json&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><br><h3 id="express-框架" tabindex="-1"><a class="header-anchor" href="#express-框架" aria-hidden="true">#</a> Express 框架</h3><p><code>Node</code> 本身并不支持其它常见的 <code>web</code> 开发任务。如果需要进行一些具体的处理，比如运行其它 <code>HTTP</code> 动词（比如 <code>GET、POST、DELETE</code> 等）、分别处理不同 <code>URL</code> 路径的请求（“路由”）、托管静态文件，或用模板来动态创建响应，那么可能就要自己编写代码了，亦或使用 <code>web</code> 框架，以避免重新发明轮子</p><p><code>Express</code> 是最流行的 <code>Node</code> 框架，是许多其它流行 <code>Node</code> 框架的底层库。它提供了以下机制：</p><ul><li>为不同 <code>URL</code> 路径中使用不同 <code>HTTP</code> 动词的请求（路由）编写处理程序</li><li>集成了“视图”渲染引擎，以便通过将数据插入模板来生成响应</li><li>设置常见 <code>web</code> 应用设置，比如用于连接的端口，以及渲染响应模板的位置</li><li>在请求处理管道的任何位置添加额外的请求处理“中间件”</li></ul><p>这些库可以实现 cookie、会话、用户登录、URL 参数、POST 数据、安全头等功能</p>`,36);function S(q,D){const t=l("RouterLink"),e=l("ExternalLinkIcon");return d(),r("div",null,[m,n("ul",null,[n("li",null,[a(t,{to:"/FrontEnd/JavaScript/"},{default:c(()=>[s("JavaScript")]),_:1})]),n("li",null,[a(t,{to:"/FrontEnd/Node.js/Express.html"},{default:c(()=>[s("Express 框架")]),_:1})])]),p(' @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=5 orderedList=false} '),p(" code_chunk_output "),v,p(" /code_chunk_output "),h,n("ul",null,[n("li",null,[f,n("blockquote",null,[n("p",null,[s("关于 "),g,s(" 的完整的选项可以在 "),n("a",b,[s("npm Docs"),a(e)]),s("上查阅")])])]),n("li",null,[n("p",null,[s("监视 node 文件更改的 "),_,s("："),n("a",j,[s("官网"),a(e)]),s(" 、 "),n("a",x,[s("配置说明"),a(e)]),s("，以及大概的配置：")]),E])]),n("blockquote",null,[n("p",null,[s("Ref： "),n("a",w,[s("Node 项目如何使用 ES 模块"),a(e)]),s(" 、 "),n("a",y,[s("tsconfig.json 的配置"),a(e)]),s(" 、 "),n("a",B,[s("Node 为什么用不了 ES 模块"),a(e)])])]),N,n("blockquote",null,[n("p",null,[s("详见： "),a(t,{to:"/FrontEnd/Node.js/Express.html"},{default:c(()=>[s("Express.md")]),_:1})])])])}const T=i(k,[["render",S],["__file","index.html.vue"]]);export{T as default};
